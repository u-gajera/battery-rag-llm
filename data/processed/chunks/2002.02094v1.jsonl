{"chunk_id": "2002.02094v1_p0_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs XINYI ZHANG, University of Pitsburgh CLAY PATTERSON, Oklahoma State University YONGPAN LIU, Tsinghua University CHENGMO YANG, University of Delaware CHUN JASON XUE, City University of Hong Kong JINGTONG HU, University of Pitsburgh Energy harvesting is an atractive way to power future IoT devices since it can eliminate the need for batery or power cables. However, harvested energy is intrinsically unstable. While FPGAs have been widely adopted in various embedded systems, it is hard to survive unstable power since all the memory components in FPGA are based on volatile SRAMs. Te emerging non-volatile memory based FPGAs provide promising potentials to keep conﬁguration data on the chip during power outages. Few works have considered implementing eﬃcient runtime intermediate data checkpoint on non-volatile FPGAs. To realize accumulative computation under intermitent power on FPGA, this paper proposes a low-cost design framework, Data-Flow-Tracking FPGA (DFT-FPGA), which utilizes binary counters to track intermediate data ﬂow. Instead of keeping all on-chip intermediate data, DFT-FPGA only targets on necessary data that is labeled by oﬀ-line analysis and identiﬁed by an online tracking system. Te evaluation shows that compared with state-of-the-art techniques, DFT-FPGA can realize accumulative computing with less oﬀ-line workload and signiﬁcantly reduce online roll-back time and resource utilization. Tis paper has been accepted by ACM Journal on Emerging Technologies in Computing Systems (JETC). CCS Concepts: •Computer systems organization →Embedded systems; Redundancy; Robotics; •Networks →Network reliabil- ity; Additional Key Words and Phrases: energy harvesting, non-volatile FPGA, checkpoint, high-level-synthesis, data ﬂow ACM Reference format: Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu. 2019. Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs. ACM Trans. Graph. 0, 0, Article 0 ( 2019), 19 pages. DOI: 00.0000/0000000.0000000 1 INTRODUCTION FPGAs have been widely adopted in various embedded systems that are powered by bateries. However, in the emerging Internet of Tings (IoT)[1–3], which is full of tiny, cost-sensitive, and space constrained widgets, bateries are no longer an ideal power supply due to poor scalability, recharging and safety concerns. Out of all possible alternatives,", "page": 0, "position": 0}
{"chunk_id": "2002.02094v1_p0_c1", "doc_id": "2002.02094v1", "text": "Non-volatile FPGAs. ACM Trans. Graph. 0, 0, Article 0 ( 2019), 19 pages. DOI: 00.0000/0000000.0000000 1 INTRODUCTION FPGAs have been widely adopted in various embedded systems that are powered by bateries. However, in the emerging Internet of Tings (IoT)[1–3], which is full of tiny, cost-sensitive, and space constrained widgets, bateries are no longer an ideal power supply due to poor scalability, recharging and safety concerns. Out of all possible alternatives, energy Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proﬁt or commercial advantage and that copies bear this notice and the full citation on the ﬁrst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permited. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speciﬁc permission and/or a fee. Request permissions from permissions@acm.org. © 2019 ACM. Manuscript submited to ACM Manuscript submited to ACM 1 arXiv:2002.02094v1 [cs.AR] 6 Feb 2020", "page": 0, "position": 1}
{"chunk_id": "2002.02094v1_p1_c0", "doc_id": "2002.02094v1", "text": "2 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu harvesting systems are becoming one of the most promising candidates because they convert ambient energy from their surroundings. Some of the widely known energy harvesting techniques include Photovoltaics (PV), Termoelectric generators (TEGs), and Piezoelectric (PZ). A device equipped with these harvesters can utilize the converted energy directly or recharge its energy storage (e.g. capacitors). Te ease of access to power makes it a very competitive power source for portable devices. However, there are two primary challenges for such energy harvesting systems: unstable power and low power input. Even though there are ultra-low power FPGAs such as the Latice iCE40 series, which can work in µW [4], the unpredictability of available energy renders the power intermitent which will interrupt computations. Te intermitent power will interrupt computations. In such a condition, long computations may be prohibited since the intermediate data will be lost and the computation has to start over from the beginning. Tus, it is essential to preserve the FPGA conf iдuration data and intermediate data during a power outage. Conf iдuration data keeps the functionality of a FPGA chip and intermediate data is the data generated during computation. By keeping both, long computations can be achieved by retrieving a checkpoint afer power resumes. Te non-volatile memory based FPGAs (NV-FPGAs) are natural candidates to address this challenge. With the substitution of NVMs such as ReRAM, STT-RAM, and PCM for SRAMs, conf iдuration data can be retained locally on the chip with beneﬁts of low leakage power, short critical path, and small area, etc [5–10]. Terefore, costs associated with loading conf iдuration data from oﬀ-chip ﬂash memories are avoided when FPGA recovers from a power outage. In the existing NV-FPGAs and traditional FPGAs, intermediate data is held by registers which consist of volatile ﬂip-ﬂops (FF). Like conf iдuration data, intermediate data needs to be saved during power is lost or weak in order to resume system state afer the power comes back. To reserve intermediate data, non-volatile ﬂip-ﬂops (NV-FFs) have been integrated on processors. Such non-volatile processor", "page": 1, "position": 0}
{"chunk_id": "2002.02094v1_p1_c1", "doc_id": "2002.02094v1", "text": "are avoided when FPGA recovers from a power outage. In the existing NV-FPGAs and traditional FPGAs, intermediate data is held by registers which consist of volatile ﬂip-ﬂops (FF). Like conf iдuration data, intermediate data needs to be saved during power is lost or weak in order to resume system state afer the power comes back. To reserve intermediate data, non-volatile ﬂip-ﬂops (NV-FFs) have been integrated on processors. Such non-volatile processor freezes all registers data locally on the chip if it is shut oﬀ[11]. Te success of NV-FFs in processors makes it a good candidate for FPGA ﬂip-ﬂop. However, FPGA’s register resource is signiﬁcantly more than the processor’s and FPGA resource utilization varies design to design. Freezing all registers on FPGA will waste rare energy in energy harvesting system. To improve eﬃciency in preserving intermediate data and reducing the roll-back impact from power interrupt, this paper proposes DFT-FPGA, a data ﬂow tracking methodology on FPGA via High-Level-Synthesis (HLS). As HLS takes sofware functions as inputs and compiles it to Register-Transfer-Level (RTL) design. DFT-FPGA builds data ﬂow trackers for such functions and a control unit to parse trackers’ status in HLS. With an oﬄine mapping of functions to trackers, DFT-FPGA can online track the intermediate data inside a function via a tracker. Ten, instead of all data, only a set of tracked intermediate data in registers will be locally stored in non-volatile ﬂip-ﬂops. In this way, the cost to preserve intermediate data can be signiﬁcantly reduced. Te main contributions of this work are as follows: • Design of binary counter based tracker framework which tracks data ﬂow in FPGA. • Design of control unit which stores the mapping of intermediate data and its on-chip physical address. • Design of an oﬀ-line intermediate data to tracker mapping algorithm. • Design of function split and merge method for DFT-FPGA. • A demonstration of the performance of NV-FF based FPGA. • A demonstration of the eﬃciency of FPGA design on representative benchmarks. Te rest of the paper is organized as follows. Section 2 presents FPGA in an energy harvesting system, non-volatile FPGA, High-Level-Synthesis, and the", "page": 1, "position": 1}
{"chunk_id": "2002.02094v1_p2_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 3 2 PRELIMINARY We will ﬁrst present FPGA in an energy harvesting system in subsection 2.1. Ten works related to NV-FPGA and NV-FF architecture will be presented in subsection 2.1.1. Te background of High-Level-Synthesis will be introduced in subsection 2.2 and the motivation of the proposed work will be presented in subsection 2.3. 2.1 FPGA and Energy Harvesting System FPGA is widely adopted in open ﬁeld applications such as wireless network platforms [12–14]. In this application scenario, the energy harvesting system outperforms other resources such as batery and cable thanks to its perpetual power supply. In energy harvesting systems, ambient energy such as solar, wind, mechanical strain, ambient radiation, and human motion can be harvested to power the energy consumer and its peripheral devices. Tough energy harvesting can provide a perpetual power supply, when compared to systems powered by cable, energy harvesting system may only harvest and supply a small amount of energy. Moreover, the passive energy harvesting approach makes the harvested energy unpredictable and unreliable. It is observed that small harvesters such as a wrist-worn motion harvester can provide about 40 µW power with worst-case power outages every 10ms in daily activities [15, 16]. Terefore, a device with the energy harvesting system should not only be able to work in a low-energy mode but also be robust enough under intermitent power. An energy harvesting system usually consists of an energy source, regulator, capacitor, and energy consumer. A classical system is shown in Fig. 1. Te regulator is a bridge between ambient energy, energy consumer, and an auxiliary capacitor. Energy consumer is powered by the regulator when harvested energy is suﬃcient. Meanwhile, the capacitor is fully charged and standby for energy spike or power outage/weak. If the ambient energy becomes weak, the additional energy from capacitor should sustain the consumer’s rest of work or preserve its current state. As the computation complexity varies from application to application, the energy needed for each application are diﬀerent. Terefore, preserving the current states are widely adopted in designs [17–19, 19–24]. Moreover, the", "page": 2, "position": 0}
{"chunk_id": "2002.02094v1_p2_c1", "doc_id": "2002.02094v1", "text": "is suﬃcient. Meanwhile, the capacitor is fully charged and standby for energy spike or power outage/weak. If the ambient energy becomes weak, the additional energy from capacitor should sustain the consumer’s rest of work or preserve its current state. As the computation complexity varies from application to application, the energy needed for each application are diﬀerent. Terefore, preserving the current states are widely adopted in designs [17–19, 19–24]. Moreover, the energy from capacitors is limited as the size of capacitors in small scale energy harvesting system can be as small as µF and under 5v [19]. For energy consumers like microcontroller, ASIC, and FPGA, their dynamic power varies from cycle to cycle. Evaluating and recording the energy from each cycle to the end can be unrealistic as a regular application can be thousands or even dozens of thousands cycles. Ambient Energy Voltage regulator Energy Consumer Auxiliary Capacitor Fig. 1. An energy harvesting system. 2.1.1 FPGA architecture. A basic FPGA architecture consists of Conﬁgurable Logic Blocks (CLB), Block RAMs (BRAMs), Connect Boxes (CB), Switch Boxes (SB), and Routing Channels which is shown in Fig. 2. Each CLB is an independent computation group and computation results are transmited via Routing Channels. Switch Boxes redirect the data in Routing Channels to horizontal or vertical channels. BRAMs in FPGA serve as long-term massive data storage during computing. In this way, a CLB can reach any other CLB in FPGA. Computation results can be stored in BRAMs. Te breakdown structure of a CLB from Xilinx FPGA is shown in Figure 3 (a). Look Up Table (LUT) is the Manuscript submited to ACM", "page": 2, "position": 1}
{"chunk_id": "2002.02094v1_p3_c0", "doc_id": "2002.02094v1", "text": "4 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu smallest programmable computation unit inside a CLB which is wrapped by Basic Logic Element (BLE). As shown in this 4-input LUT, the LUT can have diﬀerent logic by changing its mask binary order; diﬀerent combinations of inputs will lead to diﬀerent results in logic. Each LUT is followed by two ﬂip-ﬂops in a BLE which compose registers to support sequential logic in high-frequency computation. Te registers hold the intermediate results from LUTs in each clock cycle. Ten, data is sent out of CLB by Connect Box and this data is routed through Switch Boxes and Routing Channels. For a speciﬁc application, according to its complexity, a number of LUTs, ﬂip-ﬂops, Switch Boxes, and Routing Channels are selected and activated in FPGA to build its corresponding computation logic and data ﬂow path. (In Xilinx FPGA, a CLB shown in Fig 3 (a) is named as SLICE and two SLICEs form a physical CLB) For traditional FPGA, SRAMs are used to build all these components. SRAMs are usually fast but volatile. Tus, the intrinsic ﬂexibility in reconﬁguring makes an FPGA easily switch between applications. However, conﬁguring data and computation data is vanishing from the chip when power is lost or weak. In order to keep the data, part of the FPGA components need to be replaced by non-volatile memory. CLB CB CB C B C B CLB CB CB C B C B B R A m CLB CB CB C B C B CLB CB CB C B C B B R A m CLB CB CB C B C B CLB CB CB C B C B CLB CB CB C B C B CLB CB CB C B C B SB SB SB Fig. 2. An overview of FPGA architecture. (a) Configurable Logic Block Crossbar Connections BLE BLE BLE BLE BLE LUT FF FF A B C D 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 CLB CLB CLK Master Latch D Slave Latch NVM Control", "page": 3, "position": 0}
{"chunk_id": "2002.02094v1_p4_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 5 2.1.2 Non-volatile FPGA. Te study of non-volatile FPGA has been conducted by Gaillardon, Cong, et, al [25–31]. Te existing NV-FPGAs preserve all conﬁguration data on the chip. As the conﬁguration data for LUT, Connect Boxes, and Switch Boxes are stored in SRAMs bit by bit, by replacing conﬁguration data SRAMs with non-volatile memories (NVMs) such ReRAM and STT-RAM, the conﬁguration data can be permanently retained on FPGA. Tough NVMs writing and reading speed is slower than SRAMs, it can preserve its data even power is lost. Figure. 3 shows how the conﬁguration data SRAMs are replaced by NVMs on-chip [25]. In this ﬁgure, a SRAM is represented by a grey block and an NVM is represented by the green block. Te LUT conﬁguration data is stored in its mask which is held by SRAMs. Afer replacing the SRAMs in the mask with NVMs, conﬁguration data for LUT can be permanently preserved on chip afer one programming. Figure. 3 (b) and (c) show how to preserve Connect Boxes and Switch Boxes conﬁguration data with NVMs. For Switch Boxes, afer conﬁguring all control SRAMs on the connections between horizontal and vertical tracks, data paths inside Routing Channels are formed. For Connect Boxes, a SRAM determines the on/oﬀof a path between a CLB and a track. Afer conﬁguring all needed Switch Boxes and Connect Boxes, multiple data routing paths are formed. Afer adopting NVMs, the routing paths in FPGA can also be preserved. Tus, the conﬁguration data for an application can be preserved on-chip even power is oﬀ. Afer programming once, these NVMs can keep all conﬁgurations on-chip which avoids duplicate programming for the same program. SRAM based BRAMs in FPGA can also be directly replaced with non-volatile BRAMs (NV-BRAM). BRAMs are usually working as long-term massive storage on-chip. STT-MRAM based BRAMs (NV-BRAM) are proposed by Ju, et, al [31]. Compared with SRAM BRAMs, NV-BRAMs have higher density and smaller area. When substituting an SRAM with an NVM cell, six transistors are replaced with one NVM cell. Tus, for Switch Boxes,", "page": 4, "position": 0}
{"chunk_id": "2002.02094v1_p4_c1", "doc_id": "2002.02094v1", "text": "programming for the same program. SRAM based BRAMs in FPGA can also be directly replaced with non-volatile BRAMs (NV-BRAM). BRAMs are usually working as long-term massive storage on-chip. STT-MRAM based BRAMs (NV-BRAM) are proposed by Ju, et, al [31]. Compared with SRAM BRAMs, NV-BRAMs have higher density and smaller area. When substituting an SRAM with an NVM cell, six transistors are replaced with one NVM cell. Tus, for Switch Boxes, Connect Boxes, LUTs, and BRAMs, they can have a smaller area and be closer to each other in physical distance. In this way, the physical data routing distance is reduced, bringing additional beneﬁts such as higher working frequency and more energy eﬃciency. Furthermore, NVMs are compatible with CMOS technology via back-end-of-line technique [32]. By growing the NVM cells on the top of the chip, it adds non-volatility to an FPGA without increasing chip area and further reduces the area of FPGA components. An NVM based fully functional FPGA architecture is proposed by Cong, achieving 5.18x area savings, 2.28x speedup and 1.63x power savings compared with regular FPGAs [26]. 2.1.3 Non-volatile flip-flops. For the intermediate data, it is usually held in registers which are consisted of ﬂip-ﬂops. Non-volatile ﬂip-ﬂops are proposed by Qazi, Bartling, et, al [11, 33–35]. Contrary to conﬁguration data, intermediate data are frequently refreshed and the data ﬂip frequency can be hundreds of mega hertz (MHz). Tat is, at each clock cycle, the data in a register is refreshed. Terefore, the NVMs writing and reading time may bring delay which hinders the FPGA work frequency. It is observed that a 65nm technology based ReRAM NV-FF has achieved writing time as good as 4µs seconds and 46.2 pico joul per bit [11]. Meanwhile, a regular FPGA usually works at hundreds of MHz, i.e working under ns clock period. With such performance, if NVMs writing happens in NV-FF every clock cycle, the FPGA frequency may be degraded to dozens of MHz. Te architecture of NV-FF is shown in Fig. 3 (d). Based on a master-slave ﬂip-ﬂop, two pieces of NVMs are integrated to its slave logic. By adding extra NVM", "page": 4, "position": 1}
{"chunk_id": "2002.02094v1_p4_c2", "doc_id": "2002.02094v1", "text": "per bit [11]. Meanwhile, a regular FPGA usually works at hundreds of MHz, i.e working under ns clock period. With such performance, if NVMs writing happens in NV-FF every clock cycle, the FPGA frequency may be degraded to dozens of MHz. Te architecture of NV-FF is shown in Fig. 3 (d). Based on a master-slave ﬂip-ﬂop, two pieces of NVMs are integrated to its slave logic. By adding extra NVM control part, data in slave logic can be optionally stored into or retrieved from NVM cell. It works like regular ﬂip-ﬂop if NVM writing is not triggered and it can write the data to NVMs or recover data from NVM with a trigger. When writing to NVM is triggered, the clock will be hung and data is writen to NVM and vice versa. Tis avoids the writing to NVMs every clock cycle and the working frequency is not inﬂuenced if NVM writing is not triggered. Te NVM brings non-volatility but also larger logic area. It is observed in [11] that a NV-FF based processor has an extra 39% area for a single FF but less than 10% extra area for the whole chip. Te 39% single FF Manuscript submited to ACM", "page": 4, "position": 2}
{"chunk_id": "2002.02094v1_p5_c0", "doc_id": "2002.02094v1", "text": "6 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu area overhead is brought by the NVM’s control logic and the NVM is growing on the top of the chip, which won’t bring extra area. Tough NVM writing is not triggered at every clock cycle, the area overhead from the control logic will increase its intrinsic delay and the size of a CLB, leading to bigger FPGA size, which increases the routing distance. Tis may decrease the FPGA working speed. Te impacts on FPGAs working frequency afer bringing in NV-FF is evaluated in section 5. For each NV-FF, it can be triggered to work as regular, store, or retrieve mode. If other FPGA components are non-volatile, by storing the intermediate data to the NVM if power is weak, the chip state can be held on board and be retrieved later. However, selecting a single ﬂip-ﬂop in an FPGA chip is not accessible as a single ﬂip-ﬂop can not be indexed inside a CLB. Moreover, FPGA’s ﬂip-ﬂop resource can number in the thousands and tens of thousands. In the proposed design, selected ﬂip-ﬂops need to be stored in order to keep intermediate data and ﬂip-ﬂop storing and retrieve are executed SLICE by SLICE. Tis is due to FPGA tools like Vivado packing ﬂip-ﬂops into the same SLICE [36]. A physical CLB in Xilinx FPGA contains two SLICEs and each SLICE can be indexed on the chip. In general, 4 LUTs and 8 ﬂip-ﬂops or 8 LUTs and 16 ﬂip-ﬂops are placed in a SLICE. Terefore, the ﬂip-ﬂop write and retrieve are triggered SLICE by SLICE in the proposed design. In DFT-FPGA, the SLICE addresses are acquired afer FPGA synthesis and pre-loaded to FPGA. During online intermediate data tracking, such SLICE addresses can be read out afer parsing trackers’ status. Ten, the ﬂip-ﬂops in these SLICEs can be triggered in writing or retrieving. 2.2 High-Level-Synthesis (HLS) High-Level-Synthesis converts sofware language such as C/C++ to Hardware Description Language (HDL) like Verilog and VHDL. HLS’s eﬃciency and accuracy has been veriﬁed in modern FPGA applications [37–40]. It takes sofware", "page": 5, "position": 0}
{"chunk_id": "2002.02094v1_p5_c1", "doc_id": "2002.02094v1", "text": "afer FPGA synthesis and pre-loaded to FPGA. During online intermediate data tracking, such SLICE addresses can be read out afer parsing trackers’ status. Ten, the ﬂip-ﬂops in these SLICEs can be triggered in writing or retrieving. 2.2 High-Level-Synthesis (HLS) High-Level-Synthesis converts sofware language such as C/C++ to Hardware Description Language (HDL) like Verilog and VHDL. HLS’s eﬃciency and accuracy has been veriﬁed in modern FPGA applications [37–40]. It takes sofware functions F as inputs to generate HDL modules M and state transition ﬂow S. Afer HLS, a program is split into multiple modules according to program hierarchy. Tese modules are interpreted as diﬀerent states in the state transition control. State transition control initializes and terminates the modules during FPGA operation. In HLS, each function under top function is generally compiled to a standalone module. Based on the data dependency between modules (functions), these modules are triggered in parallel or sequential in state transition control. A basic HLS FPGA design with its data ﬂow control is shown in Fig. 4 [41]. In this program, there are three functions F1, F2 and F3 under top function Fmain. Afer HLS, functions are converted to modules as shown in Fig. 4 (a). In the top function, F1 and F2 have data dependency and F3 is independent of F1 and F2. Terefore, as shown in Fig. 4 (b) state transition control , F2 has to be placed afer F1 in state ﬂow S. Meanwhile, F3 can start with F1. In states S1, S2 and S3, component information in module M1, M2 and M3 such as module names, registers, connections, and cycles can be collected. An unroll of S2 is shown in Figure. 4 (c). For HLS tools like Vivado/LegUp, it maps module components to diﬀerent clock cycles and indicates the data ﬂow among clock cycles. In the real case, a state like f2 may contain sub-state, each sub-state can be unrolled according to clock cycles. Afer High-Level-Synthesis, synthesis turns HDL into the implementation of logical gates, BRAMs, and registers. It also indicates the physical placement of all modules components. Afer implementation, these components are mapped", "page": 5, "position": 1}
{"chunk_id": "2002.02094v1_p6_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 7 𝑖𝑛𝑡𝑚𝑎𝑖𝑛() { 𝑖𝑛𝑡𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3, 𝑑𝑎𝑡𝑎4; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2 ; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3 ; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛3 𝑑𝑎𝑡𝑎4 ; } 𝑚𝑜𝑑𝑢𝑙𝑒𝑚𝑎𝑖𝑛(… ) { 𝑖𝑛𝑝𝑢𝑡…; 𝑜𝑢𝑡𝑝𝑢𝑡…; 𝑟𝑒𝑔…; 𝑚𝑜𝑑𝑢𝑙𝑒𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 … ; 𝑚𝑜𝑑𝑢𝑙𝑒𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 … ; 𝑚𝑜𝑑𝑢𝑙𝑒𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛3 … ; } 𝑡𝑠𝑡𝑎𝑟𝑡 𝑡𝑒𝑛𝑑 𝑡𝑥 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑆1 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 𝑆2 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛3 𝑆3 𝑡𝑥 𝑡𝑒𝑛𝑑 resource list \\\\ • BRAM • LUT • Register … (a) Software functions to HDL (b) State transition (c) state 2 break down 𝑜𝑛𝑒𝑐𝑙𝑜𝑐𝑘𝑐𝑦𝑐𝑙𝑒 Fig. 4. High-Level-Synthesis. SLICE addresses related to diﬀerent registers are acquired. By online reading the status of trackers and parsing it to SLICE address, the SLICEs holding the intermediate data can be selected and saved. Te work ﬂow of DFT-FPGA is shown in the Figure. 5. HLS ﬁrst generates the state transition and state components information. Tracker generation builds tracker framework accordingly. Afer tracker generation, the source function combined with tracker design are HLSed one more time. Ten, synthesis generates the executable bitstream and provides all SLICE address XxxYyy. Afer programming FPGA, DFT-FPGA pre-loads the SLICE addresses to FPGA and starts the computation. Te DFT-FPGA framework will be presented in Section 3 and the oﬀ-line analysis algorithm will be presented in Section 4. Software function High-level Synthesis Tracker Generation High-level Synthesis Synthesis Slice address extraction Bitstream load Slice addr load Fig. 5. DFT-FPGA work flow. 2.3 Motivation Existing designs preserve chip state by placing checkpoints in computation [17–19, 22–24, 42]. Azalia et al. propose Chime, which places checkpoints in Register-Transfer-Level (RTL) design. Chime oﬀ-line analyzes the forward com- puting cost and back-up overhead to determine checkpoint placement. By placing checkpoint in diﬀerent locations, the computation can recover from a near checkpoint if a power outage happens. Yuan et al. propose CP−FPGA, a framework that based on HLS result. It places the diﬀerent states of the main function in diﬀerent BRAM-based (block RAM) physical areas by modifying FPGA synthesis algorithm. Each state result is stored in its dedicated BRAM and when power is lost in the mid of a state, the computation can start from its previous state. In the", "page": 6, "position": 0}
{"chunk_id": "2002.02094v1_p6_c1", "doc_id": "2002.02094v1", "text": "near checkpoint if a power outage happens. Yuan et al. propose CP−FPGA, a framework that based on HLS result. It places the diﬀerent states of the main function in diﬀerent BRAM-based (block RAM) physical areas by modifying FPGA synthesis algorithm. Each state result is stored in its dedicated BRAM and when power is lost in the mid of a state, the computation can start from its previous state. In the existing works, the intermediate data back-up is triggered at every checkpoint. Afer retrieving from a checkpoint, the computation can continue. While the prior strategies can successfully preserve the intermediate data, long roll-back can easily occur if power is lost in a long state. Tis case is shown in Fig. 6 (a), a dot represents the end of a state. Checkpoints are placed at each dot. For applications with a long state, such strategies may be hard to complete the computation if a power outage happens in the middle of a long state. Roll-back may occur several times inside a long state until power is stable. Moreover, by tying a state and a BRAM together, BRAM resources can be insuﬃcient for a large program with multiple states, and periodical data back-up happens even if power is stable. Fig 6 (b) shows the performance comparison between proposed design and periodical checkpoint design; the red line shows checkpoint technology and the green line shows DFT-FPGA. Power outage happens at t3 and t7. Checkpoints Manuscript submited to ACM", "page": 6, "position": 1}
{"chunk_id": "2002.02094v1_p7_c0", "doc_id": "2002.02094v1", "text": "8 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu are placed at progress 20%, 40% and 60%. As checkpoints are pre-deﬁned, data writing occurs at each checkpoint regardless of the power condition. Te computation starts from its previous checkpoint afer power loss. However, in DFT-FPGA, the checkpoint is avoided and data ﬂow is always tracked. Tus, data back-up happens only if power is lost and computation starts from the progress where power breaks. Compared with DFT-FPGA, the existing checkpoint placement technologies for FPGA in energy harvesting system suﬀer from long roll-back time, increasing the complexity of original program, and modifying the FPGA synthesis algorithm. Preserving the data for the entire chip may also be an option [11]. By triggering writing and retrieving of ﬂip-ﬂops in all FPGA SLICEs, all the data on chip can be fully reserved. However, such strategy can be heavily resource intensive. As FPGA resource utilization varies from design to design, preserving the entire chip causes unnecessary NVM cell writing in unused memories, which will waste rare harvested energy and slow down the writing speed. As it is shown in Figure. 6 (c), this computation only occupies 15% of the chip resource, the remaining 85% components are still stored and retrieved if preserving the whole chip data. Afer applying DFT-FPGA, unnecessary back-up can be avoided. Te beneﬁts and impact afer applying DFT-FPGA will be presented in section 5. Our previous work FC-FPGA applies shif-register like data ﬂow tracker to locate and retrieve intermediate data in RTL level [43]. In this work, binary counters are adopted to further reduce resource utilization and a full High-Level-Synthesis based work ﬂow is proposed, which signiﬁcantly reduces the workload. (a) Long state with power lost (b) Periodical checkpoint and DFT-FPGA (c) Hold all data on-chip start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 40 20 60 80 100 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 Time Power Periodical checkpoint DFT-FPGA with power failure Checkpoint time Roll-back time Progress (%) Fig. 6. The motivation example. 3 DFT-FPGA FRAMEWORK", "page": 7, "position": 0}
{"chunk_id": "2002.02094v1_p7_c1", "doc_id": "2002.02094v1", "text": "reduces the workload. (a) Long state with power lost (b) Periodical checkpoint and DFT-FPGA (c) Hold all data on-chip start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 start end 𝑠𝑡𝑎𝑡𝑒𝑛 𝑠𝑡𝑎𝑡𝑒𝑛+1 40 20 60 80 100 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 Time Power Periodical checkpoint DFT-FPGA with power failure Checkpoint time Roll-back time Progress (%) Fig. 6. The motivation example. 3 DFT-FPGA FRAMEWORK Te proposed DFT-FPGA methodology includes both framework and data-to-tracker mapping algorithm designs. In this section, we will introduce the framework of DFT-FPGA. Te algorithms that work with the framework will be introduced in Section 4. 3.1 Hardware Architecture Overview Te proposed design includes function trackers f and NV-FF control unit CU which is shown in Figure 8 (b). In this ﬁgure, a ﬁnite state machine is generated by HLS in the back-end to control data transition in functions, i.e. state transition between states. Each function is assigned a function tracker. Trackers are read by the control unit which pre-loads SLICE addresses and maps them to associated registers. In DFT-FPGA, at every power outage, the control unit reads function tracker’s status and then select the corresponding SLICE to trigger action. In the proposed design, the control path to NV-FF control part is considered already embedded in NV-FPGA. Manuscript submited to ACM", "page": 7, "position": 1}
{"chunk_id": "2002.02094v1_p8_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 9 3.2 Function Trackers As all intermediate data is held by registers, function trackers are designed to track the active registers at each clock cycle. Terefore, a tracker is built to have the same clock cycles with its corresponding function. By reading tracker’s status, the data ﬂow location in its function can be acquired. In DFT-FPGA, each function is assigned a function tracker to trace its data ﬂow. Te tracker is activated simultaneously with its corresponding function and they are terminated at the same time. Te method to insert trackers to a sofware program is shown in Figure. 7 (a). Functions F1, F2, and F3 under Fmain are assigned private trackers f1, f2, and f3. Te state transition and timing among F1−3 is as it is illustrated in Fig. 4 (b). Terefore, the initialization of trackers f1−3 should also follow such orders. In the proposed design, lock is utilized between trackers to keep trackers initialized in the right order. Te lock in a tracker consists lockhead and locktail. If a tracker is initialized afer its anterior tracker, its lockhead is the locktail of the anterior tracker. As shown in Fig. 7 (c), tracker f2′s lock2head is f1′s lock1tail . Afer tracker f1 is terminated, lock1tail is set to be 1. Tus, tracker f2 is always blocked if F1 and f1 are not ﬁnished. As there is no data dependency between function F1 and tracker f1, f1 can start with function F1 simultaneously. For trackers which start with the beginning function, such as f1, its lock1head is pre-deﬁned to be 1 to unblock itself. In this way, all trackers can be initialized and terminated with their corresponding functions. A function tracker consists of loop arbitration t, binary counter count, tracker status register fstatus, and tracker lock lockhead locktail. Without loss of generality, trackers can track function with loops or with regular operations. An example of a function and its tracker logic is shown in Fig. 7 (b) and (c). Tis is a function with an outer loop and an inner", "page": 8, "position": 0}
{"chunk_id": "2002.02094v1_p8_c1", "doc_id": "2002.02094v1", "text": "be initialized and terminated with their corresponding functions. A function tracker consists of loop arbitration t, binary counter count, tracker status register fstatus, and tracker lock lockhead locktail. Without loss of generality, trackers can track function with loops or with regular operations. An example of a function and its tracker logic is shown in Fig. 7 (b) and (c). Tis is a function with an outer loop and an inner loop. In the tracker, the ﬁrst loop t handles functions with loops. Loop iterations t corresponds to the outer loop iteration number in a function. Countmax is the length of all operations under function’s outer loop. Te binary counter increments to countmax and then be reset to zero for the next outer loop iteration. Tus, the binary counter can be reused in all outer loop iterations. If a function does not contain any loop, t is set to one and countmax is the length of the function. When power is lost during computing, the energy harvesting system sends Ploss = 1 to DFT-FPGA. With Ploss |resume = 1, the tracker sends out its status count as fstatus. Trackers’ fstatus will be further parsed by control unit. When reaching the end of tracking, the fstatus is reset to zero. In this way, the tracker can count with the function process and send out the process stage when power is loss. Afer power resumes Presume, trackers data is recovered by NV-FPGA ﬁrst and the resumed trackers’ status are utilized to wake up the stored intermediate data. To further reduce the binary size, the binary counter can be deﬁned to lower bit-width such as 4bit, 8bit, and 16bit according to the length of a function. In most cases, the binary counter size is found to be small as 4-8 bit (tracking length ranges 225-65025 cycles). Te resource utilization, tracking length, and performance of trackers in diﬀerent sizes will be discussed in section 5. 3.3 NV-FF Control Unit Te control unit read all trackers’ status fstatus. As trackers’ status is cycle accurate, by keeping the active register SLICE address for each clock cycle in", "page": 8, "position": 1}
{"chunk_id": "2002.02094v1_p8_c2", "doc_id": "2002.02094v1", "text": "a function. In most cases, the binary counter size is found to be small as 4-8 bit (tracking length ranges 225-65025 cycles). Te resource utilization, tracking length, and performance of trackers in diﬀerent sizes will be discussed in section 5. 3.3 NV-FF Control Unit Te control unit read all trackers’ status fstatus. As trackers’ status is cycle accurate, by keeping the active register SLICE address for each clock cycle in control unit, DFT-FPGA can acquire the physical location of intermediate data ﬂow. Such address can then be utilized by NV-FPGA to have SLICE registers data stored of retrieved. Te control unit also keeps the mapping relations of function trackers status and registers’ SLICE address. It consists of one or multiple BRAMs and address look-up logic as shown in Figure. 8 (a). All associated SLICE addresses for trackers are pre-loaded to cuBRAM with index fstatus+of f set. O f f set works as index boundary in cuBRAM when a new tracker is generated. And each cuBRAM[of f set] is pre-set to zero. Tus, each tracker can have a certain range Manuscript submited to ACM", "page": 8, "position": 2}
{"chunk_id": "2002.02094v1_p9_c0", "doc_id": "2002.02094v1", "text": "10 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu (a) Functions and trackers (b) Function 2 (c) Tracker 𝑓2 logic 𝑖𝑛𝑡𝑚𝑎𝑖𝑛() { 𝑖𝑛𝑡𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3, 𝑑𝑎𝑡𝑎4; 𝑏𝑜𝑜𝑙𝑙𝑜𝑐𝑘1ℎ𝑒𝑎𝑑= 1; 𝑏𝑜𝑜𝑙𝑙𝑜𝑐𝑘3ℎ𝑒𝑎𝑑= 1; 𝑏𝑜𝑜𝑙𝑙𝑜𝑐𝑘1𝑡𝑎𝑖𝑙, 𝑙𝑜𝑐𝑘3𝑡𝑎𝑖𝑙,𝑙𝑜𝑐𝑘2𝑡𝑎𝑖𝑙; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2 ; 𝑖𝑛𝑡𝑓1() ; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3 ; 𝑖𝑛𝑡𝑓2() ; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛3 𝑑𝑎𝑡𝑎4 ; 𝑖𝑛𝑡𝑓3() ; } 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑠 . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑠 } 𝑖𝑛𝑡𝑓2() { 𝑖𝑛𝑡𝑐𝑜𝑢𝑛𝑡= 0 , 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 0; 𝒊𝒇𝑙𝑜𝑐𝑘1𝑡𝑎𝑖𝑙= 1 \\\\ 𝑡𝑐𝑎𝑛𝑏𝑒1 𝒇𝒐𝒓𝑖= 1 𝑡𝑜𝑡 𝒘𝒉𝒊𝒍𝒆𝑐𝑜𝑢𝑛𝑡< 𝑐𝑜𝑢𝑛𝑡𝑚𝑎𝑥 𝑐𝑜𝑢𝑛𝑡= 𝑐𝑜𝑢𝑛𝑡+ 1 𝒊𝒇𝑝𝑙𝑜𝑠𝑠= 1 || 𝑝resume = 1 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 𝑐𝑜𝑢𝑛𝑡 𝑐𝑜𝑢𝑛𝑡= 0 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 0 𝑙𝑜𝑐𝑘2𝑡𝑎𝑖𝑙= 1 } Fig. 7. Tracker design and asignment in HLS 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛𝑡𝑟𝑎𝑐𝑘𝑒𝑟1 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛𝑡𝑟𝑎𝑐𝑘𝑒𝑟𝑛 𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛𝑛 𝑓𝑖𝑛𝑖𝑡𝑒𝑠𝑡𝑎𝑡𝑒𝑚𝑎𝑐ℎ𝑖𝑛𝑒 𝑁𝑉−𝐹𝐹𝑐𝑜𝑛𝑡𝑟𝑜𝑙𝑢𝑛𝑖𝑡 𝐹𝑃𝐺𝐴𝑐ℎ𝑖𝑝 (a) NV-FF control unit (b) Design overview (c) Control unit data struct 𝑖𝑛𝑡𝑓1_𝑠𝑡𝑎𝑡𝑢𝑠, 𝑓2_𝑠𝑡𝑎𝑡𝑢𝑠, 𝑓3_𝑠𝑡𝑎𝑡𝑢𝑠; 𝑑𝑎𝑡𝑎_𝑐𝑢𝑐𝑢_𝐵𝑅𝐴𝑀[𝑐𝑢_𝑑𝑒𝑝𝑡ℎ]; 𝑖𝑛𝑡𝑓1_𝑟𝑒𝑔𝑎𝑑𝑑𝑟, 𝑓2_𝑟𝑒𝑔𝑎𝑑𝑑𝑟, 𝑓3_𝑟𝑒𝑔𝑎𝑑𝑑𝑟; 𝑖𝑛𝑡𝑚𝑎𝑖𝑛_𝑐𝑢() { //address offset to 𝑓𝑠𝑡𝑎𝑡𝑢𝑠if in same BRAM 𝑓1_𝑟𝑒𝑔𝑎𝑑𝑑𝑟= 𝑐𝑢_𝐵𝑅𝐴𝑀[𝑓1_𝑠𝑡𝑎𝑡𝑢𝑠+ 𝑜𝑓𝑓𝑠𝑒𝑡1]; 𝑓2_𝑟𝑒𝑔𝑎𝑑𝑑𝑟= 𝑐𝑢_𝐵𝑅𝐴𝑀[𝑓2_𝑠𝑡𝑎𝑡𝑢𝑠+ 𝑜𝑓𝑓𝑠𝑒𝑡2]; 𝑓3_𝑟𝑒𝑔𝑎𝑑𝑑𝑟= 𝑐𝑢_𝐵𝑅𝐴𝑀[𝑓3_𝑠𝑡𝑎𝑡𝑢𝑠+ 𝑜𝑓𝑓𝑠𝑒𝑡3]; } 𝑡𝑦𝑝𝑒𝑑𝑒𝑓𝑠𝑡𝑟𝑢𝑐𝑡{ 𝑖𝑛𝑡𝑠𝑙𝑖𝑐𝑒_𝑥; 𝑖𝑛𝑡𝑠𝑙𝑖𝑐𝑒_𝑦; }𝑑𝑎𝑡𝑎_𝑐𝑢; 𝑖𝑛𝑡𝑓1_𝑠𝑡𝑎𝑡𝑢𝑠, 𝑓2_𝑠𝑡𝑎𝑡𝑢𝑠, 𝑓3_𝑠𝑡𝑎𝑡𝑢𝑠; 𝑑𝑎𝑡𝑎_𝑐𝑢𝑐𝑢_𝐵𝑅𝐴𝑀[𝑐𝑢_𝑑𝑒𝑝𝑡ℎ]; 𝑖𝑛𝑡𝑓1_𝑟𝑒𝑔𝑎𝑑𝑑𝑟, 𝑓2_𝑟𝑒𝑔𝑎𝑑𝑑𝑟, 𝑓3_𝑟𝑒𝑔𝑎𝑑𝑑𝑟; . . . . . . . . . Fig. 8. Control Unit and DFT-FPGA overview. of storage in cuBRAM. In this ﬁgure, all trackers fstatus is combined with oﬀset including the ﬁrst tracker f1. Tis is because trackers themselves in DFT-FPGA are needed to be reserved as well, cuBRAM keeps trackers SLICE address with index zero to of f set1. Te SLICEs where trackers are placed are always stored when power is lost. By online reading fstatus, corresponding SLICE addresses are parsed by the control unit. SLICE storing or retrieving can then be operated on these SLICEs. As tracker fstatus is zero if it is not triggered or terminated, no action to SLICEs will be executed for such trackers and the control unit will parse zero addresses. In DFT-FPGA, one BRAM cuBRAM is instantiated to keep all trackers’ mapped SLICE addresses. During HLS, if the depth of the cuBRAM is too big to be placed in a single physical BRAM, the synthesis tool will automatically expand it", "page": 9, "position": 0}
{"chunk_id": "2002.02094v1_p9_c1", "doc_id": "2002.02094v1", "text": "As tracker fstatus is zero if it is not triggered or terminated, no action to SLICEs will be executed for such trackers and the control unit will parse zero addresses. In DFT-FPGA, one BRAM cuBRAM is instantiated to keep all trackers’ mapped SLICE addresses. During HLS, if the depth of the cuBRAM is too big to be placed in a single physical BRAM, the synthesis tool will automatically expand it to multi-BRAM. As the SLICE address in FPGA is organized as Xxx Yyy, a data structure is used in DFT-FPGA to keep address in X and Y direction which is shown in Figure. 8 (c). Te resource utilization and performance of the control unit will be discussed in section 5. Afer assigning trackers to functions, there are two tasks that need to be accomplished before DFT-FPGA can work properly. First of all, for a given program with multiple functions, we need to identify which registers will keep intermediate data at a certain clock cycle in each function. Second, as tracker assignment is arranged according to function hierarchy, the main function should only contain the substantiation of functions. In this task, function merge and function split will be discussed. Manuscript submited to ACM", "page": 9, "position": 1}
{"chunk_id": "2002.02094v1_p10_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 11 4 DFT-FPGA OFF-LINE ANALYSIS In previous sections, we show how to generate and assign trackers to functions. In this section, we will present how to establish mappings between a function and its tracker, and how to merge or split functions in a program. 4.1 Function to Tracker Mapping Afer analyzing the program hierarchy and the state transition, the activation of trackers are determined. Te mapping of tracker status to data ﬂow in a function can be determined by unrolling a function’s state. A state breakdown is shown in Figure. 9 (a). In this ﬁgure, rectangle blocks represent operations inside the function and they are arranged to clock cycles from tstart to tend. At each clock cycle tn, operations ptn with its register reдtn are placed. Te connecting arrows indicate the data ﬂow inside a state. In this ﬁgure, p2 and p3 are operations for ptn+2; reд2 and reд3 are registers for reдtn+2. Every operation is followed by its register to get its data held at every clock cycle. For registers reдtn in a state, they keep the intermediate data within a function at diﬀerent clock cycles. Tose registers are the target to be tracked by trackers deﬁned with checkpointtn . As diﬀerent registers are triggered during the function process, registers that hold intermediate data for each clock cycle should be determined and those registers’ SLICE addresses are stored by the control unit. In FPGA design, operations can execute in parallel like p2 and p3. And operations may have multi-cycle length such as p4. Terefore, at certain clock cycle, there can be multiple registers reдtn or previous register reдtn′ to hold the intermediate data. Te method to determine checkpointtn is illustrated in Algorithm 1. At each cycle tn, its register reдtn is added to checkpointtn because its operations end at this cycle. If a multi-cycle operation is cross tn which starts at tn′ and ends at tn∗, the reдtn′ ahead of this operation is also added to checkpointtn , e.g, checkpointtn+2=reд2 ∪ reд3; checkpointtn+3=reд2 ∪reд3. In this way, the", "page": 10, "position": 0}
{"chunk_id": "2002.02094v1_p10_c1", "doc_id": "2002.02094v1", "text": "to hold the intermediate data. Te method to determine checkpointtn is illustrated in Algorithm 1. At each cycle tn, its register reдtn is added to checkpointtn because its operations end at this cycle. If a multi-cycle operation is cross tn which starts at tn′ and ends at tn∗, the reдtn′ ahead of this operation is also added to checkpointtn , e.g, checkpointtn+2=reд2 ∪ reд3; checkpointtn+3=reд2 ∪reд3. In this way, the registers holding intermediate data for each clock cycle are acquired. For multi-cycle operation like p4 at tn+3, DFT-FPGA inserts roll-back logic to ensure the consistency between tracker and function afer retrieve. Te roll-back logic is shown in Fig. 9 (b). Afer applying Algorithm 1 to all functions and trackers, the mappings between registers to tracker status is established. If this is a loop function as indicated by the dashed line in Fig. 9 (a), tstart to tend is tracked by count and its loop iteration is controlled by t in tracker. Te same binary counter count will be called t times. In this way, DFT-FPGA can scale down the binary counter size and save more ﬂip-ﬂop resources. By analyzing one iteration’s mapping relation, the mapping for the whole function is acquired. During synthesis, these registers’ SLICE address can be acquired. Afer that, the mappings between trackers status and SLICE address can be established. Ten, applying the mapping algorithm, registers are mapped to tracker. However, for registers barren computation, DFT-FPGA can choose to not assign tracker to if tracker ﬂip-ﬂop resources are more than target registers. Such cases are studied in section 5. Afer analyzing the mapping between a tracker and its function, the trackers for the main function Fmain need to be arranged. Te proposed DFT-FPGA will tune the hierarchy of Fmain to make it suitable for tracker assignment. Te next task includes function split and function forming. 4.2 Function Split and Merge 4.2.1 Function Split. As sofware language is normally ﬂexible in hierarchy and coding style. A program’s hierarchy may need to be tuned and then DFT-FPGA can be applied. A function needs to be split if there are", "page": 10, "position": 1}
{"chunk_id": "2002.02094v1_p11_c0", "doc_id": "2002.02094v1", "text": "12 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu Algorithm 1 Checkpointt determination Input: function state S, start point tstart , end point tend, operations ptn , registers reдtn Output: checkpointt Deﬁne: start < n < end, start < n′ < n, n < n∗< end for tn ∈S do checkpointt .append(reдtn ) for tn′ ∈S do for tn∗∈S do if reдtn′ ♦pt∗= 1 then checkpointt .append(reдtn′ ) \\\\♦ end if end for end for end for return checkpointt (a) A state with muli-cycle operation (b) Roll-back logic 𝑖𝑛𝑡𝑓2() { 𝑖𝑛𝑡𝑐𝑜𝑢𝑛𝑡= 0 , 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 0; 𝒊𝒇𝑙𝑜𝑐𝑘1𝑡𝑎𝑖𝑙= 1 \\\\ 𝑡𝑐𝑎𝑛𝑏𝑒1 𝒇𝒐𝒓𝑖= 1 𝑡𝑜𝑡 𝒘𝒉𝒊𝒍𝒆𝑐𝑜𝑢𝑛𝑡< 𝑐𝑜𝑢𝑛𝑡𝑚𝑎𝑥 𝑐𝑜𝑢𝑛𝑡= 𝑐𝑜𝑢𝑛𝑡+ 1 𝒊𝒇𝑝𝑙𝑜𝑠𝑠= 1 𝒊𝒇𝑐𝑜𝑢𝑛𝑡= 𝑡𝑛+3 𝑐𝑜𝑢𝑛𝑡= 𝑐𝑜𝑢𝑛𝑡−1 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 𝑐𝑜𝑢𝑛𝑡 𝑐𝑜𝑢𝑛𝑡= 0 𝑓𝑠𝑡𝑎𝑡𝑢𝑠= 0 𝑙𝑜𝑐𝑘2𝑡𝑎𝑖𝑙= 1 } 𝑡𝑛 𝑡𝑛+2 𝑡𝑛+4 𝑡𝑛+6 𝑝1 𝑝2 𝑝3 𝑝4 𝑝5 𝑝6 𝑝7 𝑝8 𝑡𝑛+8 𝑡𝑠𝑡𝑎𝑟𝑡 𝑡𝑒𝑛𝑑 Fig. 9. A state breakdown and roll-back logic. its all inner operations, a function is split to multiple functions according to the number of independent loops. Ten, trackers will be assigned to split functions. If a function contains more than loop functions, the function needs to be split based on the boundaries between loop and other operations. A case where a loop is followed by other operations is shown in Fig. 10 (b). It needs to be split into two functions. Trough spliting functions, the proposed tracker logic can be successfully applied. 4.2.2 Function Merge. Under the main function, there can be operations between functions. As the state transition is arranged between functions, those non-function operations will be automatically merged into a function by HLS. Tis will cause obfuscation in function-to-tracker mapping and the auto-merged function cannot be directly applied with trackers. Such a case is shown in Fig 11. By wrapping these operations to a function, state transition can be arranged in diﬀerent functions. Ten, trackers can be built and assigned to all tuned functions. 5 EXPERIMENT In this section, we ﬁrst evaluate the performance of FPGA architecture with NV-FF in subsection 5.1. Second, we evaluate the proposed tracker and control unit resource utilization and performance", "page": 11, "position": 0}
{"chunk_id": "2002.02094v1_p12_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 13 (a) Function split case 1 (b) Function split case 2 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝1 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝2 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 } 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛21 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝1 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 } 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛22 (){ \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝2 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 } 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝𝑠 . . . . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑠 } 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛21 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . 𝒇𝒐𝒓. . . \\\\ 𝑜𝑢𝑡𝑒𝑟𝑙𝑜𝑜𝑝 𝒇𝒐𝒓. . . \\\\ 𝑖𝑛𝑛𝑒𝑟𝑙𝑜𝑜𝑝} . . . 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛22 () { \\\\𝑑𝑒𝑓𝑖𝑛𝑒𝑣𝑎𝑟𝑖𝑎𝑏𝑙𝑒s . . . . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑠} Fig. 10. Function split. 𝑖𝑛𝑡𝑚𝑎𝑖𝑛() { 𝑖𝑛𝑡𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2 ; . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑐𝑜𝑑𝑒 . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑐𝑜𝑑𝑒 . . . \\\\ 𝑜𝑝𝑒𝑟𝑎𝑡𝑖𝑜𝑛𝑐𝑜𝑑𝑒 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3 ; } 𝑖𝑛𝑡𝑚𝑎𝑖𝑛() { 𝑖𝑛𝑡𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1 𝑑𝑎𝑡𝑎1, 𝑑𝑎𝑡𝑎2 ; 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛1_1(); 𝑖𝑛𝑡𝑓𝑢𝑛𝑐𝑡𝑖𝑜𝑛2 𝑑𝑎𝑡𝑎2, 𝑑𝑎𝑡𝑎3 ; } Fig. 11. Function merge. subsection 5.3. Last we evaluate the performance comparison between the periodical checkpoint and the proposed design in subsection 5.4. In experiments, tool Verilog-To-Routing (VTR) is used in evaluating the FPGA architecture with NV-FF in subsection 5.1. Vivado HLS is used in remaining evaluations for analyzing and generating DFT-FPGA and analyzing benchmarks. Vivado is used in FPGA synthesis and geting all registers SLICE address. 5.1 NV-FF FPGA performance In this subsection, we base on FPGA architecture K6−f rac −N10−mem32K −40nm from VTR, by adding delay to its D ﬂip-ﬂop module and increasing CLB area to evaluate the impact from NV-FFs. As presented in section 2.1.3, the control part in NV-FF brings extra area. Increasing the area of a single ﬂip-ﬂop can degrade its timing performance but ﬂip-ﬂop area size is not simulated in VTR. Terefore, we add extra delay to each single ﬂip-ﬂop according to the area scaling up ratio 39% and 49% [11, 44]. Te", "page": 12, "position": 0}
{"chunk_id": "2002.02094v1_p12_c1", "doc_id": "2002.02094v1", "text": "its D ﬂip-ﬂop module and increasing CLB area to evaluate the impact from NV-FFs. As presented in section 2.1.3, the control part in NV-FF brings extra area. Increasing the area of a single ﬂip-ﬂop can degrade its timing performance but ﬂip-ﬂop area size is not simulated in VTR. Terefore, we add extra delay to each single ﬂip-ﬂop according to the area scaling up ratio 39% and 49% [11, 44]. Te extra 39% case is caused by additional 15T2R, which is 15 transistors and 2 ReRAMs [11]. Te extra 49% case is caused by additional 22T2R, which is 22 transistors and 2 ReRAMs [44]. Te increase of ﬂip-ﬂop size also brings a larger CLB area, which will lead to longer routing distancedistance and may degrade FPGA’s working frequency. In the evaluated FPGA architecture, each CLB contains 10 ﬂip-ﬂops. For the two types of NV-FF structure, due to VTR adopts minimum width transistor area [45] to deﬁne the size of components, we increase the CLB size by 15 minimum width transistor area and 22 minimum width transistor area accordingly. Te FPGA architecture size increment is shown in Figure. 12 (a). In this ﬁgure, the blue column represents the base architecture, the orange column represents the 15T2R architecture, and the grey column represents the 22T2R architecture. We observe a 0.2% logic area increasing from base to 15T2R and 0.07% from 15T2R to 22T2R. Routing area increases 0.16% from base to 15T2R and 0.04% from 15T2R to 22T2R. Manuscript submited to ACM", "page": 12, "position": 1}
{"chunk_id": "2002.02094v1_p13_c0", "doc_id": "2002.02094v1", "text": "14 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu To evaluate the impact on FPGA working frequency which suﬀers from longer ﬂip-ﬂop delay and routing distance, we apply seven benchmarks in VTR on three FPGA architectures, respectively. Te critical path delay and maximum working frequency are shown in Fig. 12 (b) and (c). In the evaluated benchmarks, we observe that 15T2R architecture causes less than 3% of additional critical path delay and 22T2R architecture causes less than 7.4% additional critical path delay compared to base architecture. As the critical path delay determined the maximum working frequency, we also show the maximum working frequency in Fig. 12 (c). We can observe that less than 6.5MHz degradation is caused by 15T2R and less than 10MHz is caused by 22T2R. From the evaluation, we can see that integrating NV-FF on FPGA brings a bit performance degradation, i.e, several MHz. However, as most designs running on FPGA work at hundreds of MHz [37, 39, 46, 47], such degradation has litle impact on overall performance and achieves non-volatility of ﬂip-ﬂops. ns MHz (a) NV-FF FPGA architecture area (b) Critical path delay (c) Maximum working frequency minimum width transistor area Regular 15T2R 22T2R Fig. 12. NV-FPGA performance. 5.2 Tracker and Control Unit Evaluation In the previous section, we evaluated the performance of NV-FF based FPGA architecture. In this section, we will evaluate the resource utilization and timing performance of DFT-FPGA framework. Te evaluation is based on FPGA chip xc7z020clд484. Table 1 shows the ﬂip-ﬂop, LUTs usages, and maximum tracking cycles when a tracker size scales from 4bit to 9bit. Te resource of xc7z020clд484 is also listed. In the evaluation, we observe less than 0.03% of ﬂip-ﬂops and less than 0.21% LUTs are used to build a tracker. Similarly, less than 0.05% of ﬂip-ﬂops and less than 0.31% LUTs are used to build a control unit. If applying DFT-FPGA on large scale FPGAs, the utilization ratio will be further reduced. Te maximum tracking cycles are Max Cycle = t ∗countmax which is illustrated in in section 3.2. For example, 8-bit tracker", "page": 13, "position": 0}
{"chunk_id": "2002.02094v1_p13_c1", "doc_id": "2002.02094v1", "text": "observe less than 0.03% of ﬂip-ﬂops and less than 0.21% LUTs are used to build a tracker. Similarly, less than 0.05% of ﬂip-ﬂops and less than 0.31% LUTs are used to build a control unit. If applying DFT-FPGA on large scale FPGAs, the utilization ratio will be further reduced. Te maximum tracking cycles are Max Cycle = t ∗countmax which is illustrated in in section 3.2. For example, 8-bit tracker can count a function with up to 65025 = 255 ∗255 cycles. Te control unit keeps SLICE addresses and indexes it afer reading trackers’ status. Te control unit’s resource utilization is shown in Table 2. In this table, we show the resource of a control unit with one tracker when tracker size scales from 4bit to 9bit. A n bit counter needs countmax depth in BRAM to store SLICE address because the count start over when enter each iteration of t. Tus, the depth needed for a tracker is much smaller than the length of a function. When the counter is less than 8bit, Vivado HLS optimizes it into ﬂip-ﬂops and LUTs to save BRAM resource. Te timing performance of a DFT-FPGA framework is shown in Table 3. In this evaluation, we measure the maximum working frequency of 8-bit standalone tracker, standalone control unit, and DFT-FPGA which is an integration of one 8-bit tracker and control unit. We can observe that a standalone tracker can work up to 500MHz and a standalone control unit can work up to 400MHz on FPGA xc7z020clд484. With the evaluated NV-FF FPGA performance and the DFT-FPGA performance, we can conclude that the DFT-FPGA consumes a small amount of FPGA resources and will not be the speed botleneck afer being applied to the source program. Manuscript submited to ACM", "page": 13, "position": 1}
{"chunk_id": "2002.02094v1_p14_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 15 Table 1. Tracker Resource Utilization Tracker size 4bit 5bit 6bit 7bit 8bit 9bit FPGA FFs 15 18 21 24 27 30(0.03%) 106400 LUTs 90 102 102 102 102 110(0.21%) 53200 Max Cycle 225 961 3969 16129 65025 261121 - Table 2. Control Unit Resource Utilization Tracker size 4bit 5bit 6bit 7bit 8bit 9bit FPGA FFs 52 52 52 52(0.05%) 36 36 106400 LUTs 138 142 150 166(0.31%) 134 134 53200 BRAM ∼ ∼ ∼ ∼ 2 2 280 Table 3. DFT-FPGA Working Frequency Frequency 100MHz 150MHz 200MHz 400MHz 450MHz 500MHz 600MHz Tracker √ √ √ √ √ √ × Control Unit √ √ √ √ × × × DFT-FPGA √ √ √ √ × × × 5.3 DFT-FPGA Case study In the previous section, we showed the performance of a tracker, a control unit and an individual DFT-FPGA frame- work. In this section, we evaluate the performance of HLS benchmarks from CHStone [48] on FPGA xc7z020clд484 with/without applying DFT-FPGA under 400 MHz working frequency. Te benchmarks cover large size benchmark such as adpcm and small size benchmark such as struct. Table 4 and 5 show the resource utilization of source benchmarks and benchmarks applyied DFT-FPGA (DFT). In the table, resources such as BRAM, DSP, ﬂip-ﬂop, LUT, and SLICE are listed. For the source benchmarks, the resource usage and utilization level are presented. For DFT-FPGA, its resource usage includes source benchmark and the applied DFT-FPGA framework. Te resource usage and utilization level increment are shown in the table for DFT-FPGA. For benchmarks with higher resource utilization, such as adpcm, aes, дsm, and f loat, a less than 1.5% resource increment is observed. DFT-FPGA generates trackers and control unit to track their data ﬂow. For small benchmarks such as дlobal and struct, less than 0.3% resource increment is observed. Such benchmarks consume a small number of ﬂip-ﬂops and LUTs, which is even less than its tracker’s resource requirement. For such benchmarks, DFT-FPGA only generates control unit to keep all associated SLICE addresses and save all data. In this way, DFT-FPGA", "page": 14, "position": 0}
{"chunk_id": "2002.02094v1_p14_c1", "doc_id": "2002.02094v1", "text": "increment is observed. DFT-FPGA generates trackers and control unit to track their data ﬂow. For small benchmarks such as дlobal and struct, less than 0.3% resource increment is observed. Such benchmarks consume a small number of ﬂip-ﬂops and LUTs, which is even less than its tracker’s resource requirement. For such benchmarks, DFT-FPGA only generates control unit to keep all associated SLICE addresses and save all data. In this way, DFT-FPGA achieves resource eﬃciency in diﬀerent sizes of benchmarks. Te proposed design shows good adaptability when source programs’ size scales up and scales down. It consumes a small number of FPGA resources to achieve intermediate data tracking in the analyzed benchmarks. Table 4. DFT-FPGA in Diﬀerent Benchmarks Benchmarks adpcm aes gsm FPGA source DFT source DFT source DFT BRAM 14(5%) 16 (+0.7%) 9(3%) 11 (+0.07%) 7(2.5%) 9 (+0.7%) 280 DSP 114(51.8%) 114(+0%) 0(0%) 0(+0%) 46(20.9%) 46(+0%) 220 FF 3464(3.3%) 3769 (+0.28%) 1028(0.96%) 1321 (+0.28%) 1435(1.3%) 1682 (+0.23%) 106400 LUT 8293(15.6%) 8928 (+1.2%) 4552(8.6%) 5330 (+1.5%) 3903(7.3%) 4487 (+1%) 53200 SLICE - 472 - 166 - 211 13300 Manuscript submited to ACM", "page": 14, "position": 1}
{"chunk_id": "2002.02094v1_p15_c0", "doc_id": "2002.02094v1", "text": "16 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu Table 5. DFT-FPGA in Diﬀerent Benchmarks Benchmarks ﬂoat global struct FPGA source DFT source DFT source DFT BRAM 14(5%) 16 (+0.7%) 3(1%) 3 (+0%) 4(1.4%) 4(+0%) 280 DSP 14(6.4%) 14(+0%) 0(0%) 0(+0%) 0(0%) 0(+0%) 220 FF 2997(2.8%) 3210 (+0.2%) 74(0.07%) 284 (+0.19%) 58(0.05%) 267 (+0.19%) 106400 LUT 4901(9.2%) 5150 (+0.47%) 713(1.3%) 882 (+0.3%) 228(0.4%) 380 (+0.28%) 53200 SLICE - 402 - 36 - 34 13300 5.4 Comparison DFT-FPGA with Checkpoint Technology In the previous section, we evaluated the resource utilization of DFT-FPGA in diﬀerent benchmarks. In this section, we will present the comparison between DFT-FPGA and periodical checkpoint CP-FPGA in resource, roll-back time, and ﬂip-ﬂop storing under diﬀerent power conditions. As CP-FPGA places checkpoints at the end of all states and saves checkpoint to a BRAM, the number of extra BRAMs brought by CP-FPGA equals the number of states in a benchmark. In the proposed design, the extra BRAM is brought by control unit, which stores SLICE addresses. In table 6, we show the number of states in each benchmark and BRAM utilization in DFT-FPGA and CP-FPGA. In FPGA xc7z020clд484, a single BRAM stores 18Kb data. As shown in the table, the BRAM resource is signiﬁcantly decreased in DFT-FPGA. Tis is because the BRAM in DFT-FPGA is generated according to the number of SLICEs needed to be tracked. Each BRAM in DFT-FPGA is fully utilized. BRAM in CP-FPGA can not be fully utilized as it is assigned by state number, regardless of the size of state result. Table 6. BRAM usage in DFT-FPGA and CP-FPGA Benchmarks adpcm aes gsm ﬂoat global struct states 24 8 13 1 3 2 BRAM DFT 2 2 2 2 0 0 BRAM CP 24(12x) 8(4x) 13(6.5x) 1 3(3x) 2(2x) Te roll-back time and the number of stored ﬂip-ﬂops in diﬀerent benchmarks are shown in Figure 13 and Figure 14. In Fig. 13, the x-axis shows the number of power lost during benchmarks running and the y-axis shows the roll-back clock cycles. Power lost is randomly triggered within a benchmark’s", "page": 15, "position": 0}
{"chunk_id": "2002.02094v1_p15_c1", "doc_id": "2002.02094v1", "text": "13 1 3 2 BRAM DFT 2 2 2 2 0 0 BRAM CP 24(12x) 8(4x) 13(6.5x) 1 3(3x) 2(2x) Te roll-back time and the number of stored ﬂip-ﬂops in diﬀerent benchmarks are shown in Figure 13 and Figure 14. In Fig. 13, the x-axis shows the number of power lost during benchmarks running and the y-axis shows the roll-back clock cycles. Power lost is randomly triggered within a benchmark’s computation length, e.g at power lost is 5, there are 5 power lost during computing and every power lost is randomly triggered. In the evaluation, we simulate the number of power lost from 1 to 10 during the computation to mimic diﬀerent power conditions. Without loss of generality, for each power lost case, we record the result of its mean of 10 test rounds. As shown in the ﬁgure, the roll-back time for the proposed design is near zero in all benchmarks and all power conditions. Our performance is not inﬂuenced even if power condition is worse. Tis is because the data ﬂow inside each state is aware by DFT-FPGA; DFT-FPGA can retrieve computation from where it is interrupted. For CP-FPGA, it needs to ﬁnd its nearest checkpoint and recover from that point. If the length of states is long in benchmarks, the interval between two checkpoints is far from each other. It causes long roll-back if power is lost during the middle of such state. Tis is observed in the дsm benchmark which consists of multiple states with over one thousand cycles each. When power lost occurs in one of such states, long roll-back happens. Te performance of periodical placing checkpoint technology is signiﬁcantly inﬂuenced by the source program and power condition. Meanwhile, the proposed DFT-FPGA shows good adaptability in minimized roll-back time for diﬀerent benchmarks in diﬀerent power conditions. Figure 14 shows the stored ﬂip-ﬂop data for benchmarks in diﬀerent power conditions. In this ﬁgure, we record the number of ﬂip-ﬂops that are stored in CP-FPGA and the proposed design. Te x-axis shows the power lost case Manuscript submited to ACM", "page": 15, "position": 1}
{"chunk_id": "2002.02094v1_p16_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 17 ranging from 1 to 10. Te y-axis shows the number of ﬂip-ﬂops that are stored afer ﬁnishing computation. As CP-FPGA periodically places checkpoints in design, the number of ﬂip-ﬂops stored is a constant in all power conditions. Afer a state is called, it stores its state result data in registers to BRAM as a checkpoint. It leads to unnecessary data storing when power lost happens occasionally such as once or twice in computation. For DFT-FPGA, the number of ﬂip-ﬂops which is saved consists of both intermediate data registers and trackers’ ﬂip-ﬂop resources. We can observe linear increasing in ﬂip-ﬂops when the number of power lost becomes worse. Tis is because the data storage in DFT-FPGA happens only at power lost. Periodical placing checkpoint may have fewer ﬂip-ﬂops usages if a small number of checkpoints are placed. Such as truct, it is arranged to several long states. CP-FPGA have less ﬂip-ﬂop storing in such benchmarks. However, it brings long roll-back time as shown in Fig. 13. 0 5 10 0 100 200 300 adpcm_cp adpcm_dft 0 5 10 0 50 100 aes_cp aes_dft 0 5 10 0 1000 2000 3000 4000 gsm_cp gsm_dft 0 5 10 0 50 100 150 200 float_cp float_dft 0 5 10 0 5 10 global_cp global_dft 0 5 10 0 10 20 30 struct_cp struct_dft Fig. 13. Roll-back time in CP-FPGA and DFT-FPGA. 0 5 10 0 2 4 6 104 adpcm_cp adpcm_dft 0 5 10 0 1000 2000 3000 aes_cp aes_dft 0 5 10 0 1000 2000 3000 gsm_cp gsm_dft 0 5 10 0 5000 10000 15000 float_cp float_dft 0 5 10 0 0.5 1 1.5 2 104 global_cp global_dft 0 5 10 0 500 1000 1500 2000 struct_cp struct_dft Fig. 14. Flip-flop operations in CP-FPGA and DFT-FPGA. 6 CONCLUSION We propose a data-ﬂow tracking framework, DFT-FPGA, for non-volatile FPGA. It is a full High-Level-Synthesis based framework targeting non-volatile FPGA that can online track and locate the physical location of intermediate data. By parsing, storing, and retrieving certain area of FPGA SLICE, the", "page": 16, "position": 0}
{"chunk_id": "2002.02094v1_p16_c1", "doc_id": "2002.02094v1", "text": "0.5 1 1.5 2 104 global_cp global_dft 0 5 10 0 500 1000 1500 2000 struct_cp struct_dft Fig. 14. Flip-flop operations in CP-FPGA and DFT-FPGA. 6 CONCLUSION We propose a data-ﬂow tracking framework, DFT-FPGA, for non-volatile FPGA. It is a full High-Level-Synthesis based framework targeting non-volatile FPGA that can online track and locate the physical location of intermediate data. By parsing, storing, and retrieving certain area of FPGA SLICE, the proposed design can assist NV-FPGA in intermitent computing with minimum resource overhead. Te proposed DFT-FPGA also shows good adaptability in diﬀerent benchmarks under various power conditions with beter resource utilization and less roll-back time. 7 ACKNOWLEDGEMENTS Tis work was supported in part by the National Science Foundation under Grant CCF-1820537, in part by the National Natural Science Foundation of China under Grant 61934005, in part by the National Natural Science Foundation of China under Grant 61674094, in part by the National Science Foundation under Grant CCF-1527464, and in part by the Research Grants Council of the Hong Kong Special Administrative Region, China under Grant CityU 11278316. REFERENCES [1] Xiaowei Xu, Yukun Ding, Sharon Xiaobo Hu, Michael Niemier, Jason Cong, Yu Hu, and Yiyu Shi. Scaling for edge inference of deep neural networks. Nature Electronics, 1(4):216, 2018. [2] Xiaowei Xu, Qing Lu, Tianchen Wang, Jinglan Liu, Cheng Zhuo, Xiaobo Sharon Hu, and Yiyu Shi. Edge segmentation: Empowering mobile telemedicine with compressed cellular neural networks. In Proceedings of the 36th International Conference on Computer-Aided Design, pages 880–887. IEEE Press, 2017. [3] Xiaowei Xu, Dewen Zeng, Wenyao Xu, Yiyu Shi, and Yu Hu. An eﬃcient memristor-based distance accelerator for time series data mining on data centers. In 2017 54th ACM/EDAC/IEEE Design Automation Conference (DAC), pages 1–6. IEEE, 2017. Manuscript submited to ACM", "page": 16, "position": 1}
{"chunk_id": "2002.02094v1_p17_c0", "doc_id": "2002.02094v1", "text": "18 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu [4] Latice. ice40 lp/hx/lm. latice, 2017. [5] Xifan Tang, Pierre-Emmanuel Gaillardon, and Giovanni De Micheli. A high-performance low-power near-vt rram-based fpga. In 2014 International Conference on Field-Programmable Technology (FPT), pages 207–214. IEEE, 2014. [6] Xifan Tang, Gain Kim, Pierre-Emmanuel Gaillardon, and Giovanni De Micheli. A study on the programming structures for rram-based fpga architectures. IEEE Transactions on Circuits and Systems I: Regular Papers, 63(4):503–516, 2016. [7] Weisheng Zhao, Eric Belhaire, Claude Chappert, and Pascale Mazoyer. Spin transfer torque (st)-mram–based runtime reconﬁguration fpga circuit. ACM Transactions on Embedded Computing Systems (TECS), 9(2):14, 2009. [8] Xiaochen Guo, Engin Ipek, and Tolga Soyata. Resistive computation: avoiding the power wall with low-leakage, st-mram based computing. In ACM SIGARCH Computer Architecture News, volume 38, pages 371–382. ACM, 2010. [9] Pierre-Emmanuel Gaillardon, M Haykel Ben-Jamaa, Marina Reyboz, Giovanni Beti Beneventi, Fabien Clermidy, Luca Perniola, and Ian O’Connor. Phase-change-memory-based storage elements for conﬁgurable logic. In 2010 International Conference on Field-Programmable Technology (FPT), pages 17–20. IEEE, 2010. [10] Yibo Chen, Jishen Zhao, and Yuan Xie. 3d-nonfar: three-dimensional non-volatile fpga architecture using phase change memory. In Proceedings of the 16th ACM/IEEE international symposium on Low power electronics and design, pages 55–60. ACM, 2010. [11] Albert Lee, Chieh-Pu Lo, Chien-Chen Lin, Wei-Hao Chen, Kuo-Hsiang Hsu, Zhibo Wang, Fang Su, Zhe Yuan, Qi Wei, Ya-Chin King, and Chrong-Jung Lin. A reram-based nonvolatile ﬂip-ﬂop with self-write-termination scheme for frequent-oﬀfast-wake-up nonvolatile processors. IEEE Journal of Solid-State Circuits, 52(8):2194–2207, 2017. [12] Vilabha S Patil, Yashwant B Mane, and Shraddha Deshpande. Fpga based power saving technique for sensor node in wireless sensor network (wsn). In Computational Intelligence in Sensor Networks, pages 385–404. Springer, 2019. [13] Billel Bengherbia, Mohamed Ould Zmirli, Abdelmoghni Toubal, and Abderrezak Guessoum. Fpga-based wireless sensor nodes for vibration monitoring system and fault diagnosis. Measurement, 101:81–92, 2017. [14] Abdulfatah M Obeid, Fatma Karray, Mohamed Wassim Jmal, Mohamed Abid, Syed Manzoor Qasim, and Mohammed S BenSaleh. Towards realisation of wireless sensor network-based water pipeline monitoring systems: a comprehensive review of techniques and platforms. IET science, measurement & technology, 10(5):420–426,", "page": 17, "position": 0}
{"chunk_id": "2002.02094v1_p17_c1", "doc_id": "2002.02094v1", "text": "pages 385–404. Springer, 2019. [13] Billel Bengherbia, Mohamed Ould Zmirli, Abdelmoghni Toubal, and Abderrezak Guessoum. Fpga-based wireless sensor nodes for vibration monitoring system and fault diagnosis. Measurement, 101:81–92, 2017. [14] Abdulfatah M Obeid, Fatma Karray, Mohamed Wassim Jmal, Mohamed Abid, Syed Manzoor Qasim, and Mohammed S BenSaleh. Towards realisation of wireless sensor network-based water pipeline monitoring systems: a comprehensive review of techniques and platforms. IET science, measurement & technology, 10(5):420–426, 2016. [15] T Xue and S Roundy. Analysis of magnetic plucking conﬁgurations for frequency up-converting harvesters. In Journal of Physics: Conference Series, volume 660, page 012098. IOP Publishing, 2015. [16] Kaisheng Ma, Xueqing Li, Jinyang Li, Yongpan Liu, Yuan Xie, Jack Sampson, Mahmut Taylan Kandemir, and Vijaykrishnan Narayanan. Incidental computing on iot nonvolatile processors. In Proceedings of the 50th Annual IEEE/ACM International Symposium on Microarchitecture, pages 204–218. ACM, 2017. [17] Kaisheng Ma, Xueqing Li, Shuangchen Li, Yongpan Liu, John Jack Sampson, Yuan Xie, and Vijaykrishnan Narayanan. Nonvolatile processor architecture exploration for energy-harvesting applications. IEEE Micro, 35(5):32–40, 2015. [18] Kiwan Maeng, Alexei Colin, and Brandon Lucia. Alpaca: intermitent execution without checkpoints. Proceedings of the ACM on Programming Languages, 1(OOPSLA):96, 2017. [19] Chen Pan, Mimi Xie, Yongpan Liu, Yanzhi Wang, Chun Jason Xue, Yuangang Wang, Yiran Chen, and Jingtong Hu. A lightweight progress maximization scheduler for non-volatile processor under unstable energy harvesting. In Proceedings of the 18th ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems, pages 101–110. ACM, 2017. [20] Domenico Balsamo, Alex S Weddell, GeoﬀV Merret, Bashir M Al-Hashimi, Davide Brunelli, and Luca Benini. Hibernus: Sustaining computation during intermitent supply for energy-harvesting systems. IEEE Embedded Systems Leters, 7(1):15–18, 2015. [21] Mimi Xie, Mengying Zhao, Chen Pan, Jingtong Hu, Yongpan Liu, and Chun Jason Xue. Fixing the broken time machine: Consistency-aware checkpointing for energy harvesting powered non-volatile processor. In Proceedings of the 52nd Annual Design Automation Conference, page 184. ACM, 2015. [22] Mimi Xie, Mengying Zhao, Chen Pan, Hehe Li, Yongpan Liu, Youtao Zhang, Chun Jason Xue, and Jingtong Hu. Checkpoint aware hybrid cache architecture for nv processor in energy harvesting powered systems. In Proceedings of the Eleventh IEEE/ACM/IFIP", "page": 17, "position": 1}
{"chunk_id": "2002.02094v1_p17_c2", "doc_id": "2002.02094v1", "text": "Yongpan Liu, and Chun Jason Xue. Fixing the broken time machine: Consistency-aware checkpointing for energy harvesting powered non-volatile processor. In Proceedings of the 52nd Annual Design Automation Conference, page 184. ACM, 2015. [22] Mimi Xie, Mengying Zhao, Chen Pan, Hehe Li, Yongpan Liu, Youtao Zhang, Chun Jason Xue, and Jingtong Hu. Checkpoint aware hybrid cache architecture for nv processor in energy harvesting powered systems. In Proceedings of the Eleventh IEEE/ACM/IFIP International Conference on Hardware/Sofware Codesign and System Synthesis, page 22. ACM, 2016. [23] Azalia Mirhoseini, Bita Darvish Rouhani, Ebrahim Songhori, and Farinaz Koushanfar. Chime: Checkpointing long computations on interm itently energized iot devices. IEEE Transactions on Multi-Scale Computing Systems, 2(4):277–290, 2016. [24] Zhe Yuan, Yongpan Liu, Hehe Li, and Huazhong Yang. Cp-fpga: Computation data-aware sofware/hardware co-design for nonvolatile fpgas based on checkpointing techniques. In Design Automation Conference (ASP-DAC), 2016 21st Asia and South Paciﬁc, pages 569–574. IEEE, 2016. [25] P-E Gaillardon, Davide Saccheto, Giovanni Beti Beneventi, M Haykel Ben Jamaa, Luca Perniola, Fabien Clermidy, Ian O’Connor, and Giovanni De Micheli. Design and architectural assessment of 3-d resistive memory technologies in fpgas. IEEE Transactions on Nanotechnology, 12(1):40–50, 2013. [26] Jason Cong and Bingjun Xiao. mrfpga: A novel fpga architecture with memristor-based reconﬁguration. In 2011 IEEE/ACM International Symposium on Nanoscale Architectures, pages 1–8. IEEE, 2011. [27] Ramtin Zand and Ronald F DeMara. Radiation-hardened mram-based lut for non-volatile fpga sof error mitigation with multi-node upset tolerance. Journal of Physics D: Applied Physics, 50(50):505002, 2017. Manuscript submited to ACM", "page": 17, "position": 2}
{"chunk_id": "2002.02094v1_p18_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 19 [28] Kangwook Jo, Kyungseon Cho, and Hongil Yoon. Variation-tolerant and low power look-up table (lut) using spin-torque transfer magnetic ram for non-volatile ﬁeld programmable gate array (fpga). In 2016 International SoC Design Conference (ISOCC), pages 101–102. IEEE, 2016. [29] Haider Abbas F Almurib, Tulasiraman Nandha Kumar, and Fabrizio Lombardi. Design and evaluation of a memristor-based look-up table for non-volatile ﬁeld programmable gate arrays. IET Circuits, Devices & Systems, 10(4):292–300, 2016. [30] Ramin Rajaei. Radiation-hardened design of nonvolatile mram-based fpga. IEEE Transactions on Magnetics, 52(10):1–10, 2016. [31] Lei Ju, Xiaojin Sui, Shiqing Li, Mengying Zhao, Chun Jason Xue, Jingtong Hu, and Zhiping Jia. Nvm-based fpga block ram with adaptive slc-mlc conversion. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 37(11):2661–2672, 2018. [32] H-S Philip Wong, Heng-Yuan Lee, Shimeng Yu, Yu-Sheng Chen, Yi Wu, Pang-Shiu Chen, Byoungil Lee, Frederick T Chen, and Ming-Jinn Tsai. Metal–oxide rram. Proceedings of the IEEE, 100(6):1951–1970, 2012. [33] Santhosh Onkaraiah, Marina Reyboz, Fabien Clermidy, Jean-Michel Portal, Marc Bocquet, Chritophe Muller, Hraziia, Costin Anghel, and Amara Amara. Bipolar reram based non-volatile ﬂip-ﬂops for low-power architectures. In 2012 IEEE 10th International New Circuits and Systems Conference (NEWCAS), pages 417–420. IEEE, 2012. [34] K Jabeur, G Di Pendina, and G Prenat. Ultra-energy-eﬃcient cmos/magnetic nonvolatile ﬂip-ﬂop based on spin-orbit torque device. Electronics Leters, 50(8):585–587, 2014. [35] Tsai-Kan Chien, Lih-Yih Chiou, Yao-Chun Chuang, Shyh-Shyuan Sheu, Heng-Yuan Li, Pei-Hua Wang, Tzu-Kun Ku, Ming-Jinn Tsai, and Chih-I Wu Wu. A low store energy and robust reram-based ﬂip-ﬂop for normally oﬀmicroprocessors. In 2016 IEEE International Symposium on Circuits and Systems (ISCAS), pages 2803–2806. IEEE, 2016. [36] Xilinx. Xilinx ﬂoorplanning methodology guide. Xilinx, 2009. [37] Razvan Nane, Vlad-Mihai Sima, Christian Pilato, Jongsok Choi, Blair Fort, Andrew Canis, Yu Ting Chen, Hsuan Hsiao, Stephen Brown, Fabrizio Ferrandi, et al. A survey and evaluation of fpga high-level synthesis tools. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 35(10):1591–1604, 2015. [38] Denis Navarro, ´Oscar Lucı, Luis A Barrag´an, Isidro Urriza, Oscar Jimenez, et al. High-level synthesis for accelerating the fpga implementation of computationally", "page": 18, "position": 0}
{"chunk_id": "2002.02094v1_p18_c1", "doc_id": "2002.02094v1", "text": "Xilinx, 2009. [37] Razvan Nane, Vlad-Mihai Sima, Christian Pilato, Jongsok Choi, Blair Fort, Andrew Canis, Yu Ting Chen, Hsuan Hsiao, Stephen Brown, Fabrizio Ferrandi, et al. A survey and evaluation of fpga high-level synthesis tools. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 35(10):1591–1604, 2015. [38] Denis Navarro, ´Oscar Lucı, Luis A Barrag´an, Isidro Urriza, Oscar Jimenez, et al. High-level synthesis for accelerating the fpga implementation of computationally demanding control algorithms for power converters. IEEE Transactions on Industrial Informatics, 9(3):1371–1379, 2013. [39] Weiwen Jiang, Edwin H-M Sha, Xinyi Zhang, Lei Yang, Qingfeng Zhuge, Yiyu Shi, and Jingtong Hu. Achieving super-linear speedup across multi-fpga for real-time dnn inference. ACM Transactions on Embedded Computing Systems (TECS), 18(5s):67, 2019. [40] Weiwen Jiang, Xinyi Zhang, Edwin H-M Sha, Lei Yang, Qingfeng Zhuge, Yiyu Shi, and Jingtong Hu. Accuracy vs. eﬃciency: Achieving both through fpga-implementation aware neural architecture search. arXiv preprint arXiv:1901.11211, 2019. [41] Andrew Canis, Jongsok Choi, Mark Aldham, Victor Zhang, Ahmed Kammoona, Tomasz Czajkowski, Stephen D Brown, and Jason H Anderson. Legup: An open-source high-level synthesis tool for fpga-based processor/accelerator systems. ACM Transactions on Embedded Computing Systems (TECS), 13(2):24, 2013. [42] Saad Ahmed, Muhammad Hamad Alizai, Junaid Haroon Siddiqui, Naveed Anwar Bhati, and Luca Motola. Towards smaller checkpoints for beter intermitent computing. In 2018 17th ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN), pages 132–133. IEEE, 2018. [43] Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtiong Hu. Low overhead online checkpoint for intermitently powered non-volatile fpgas. In 2018 IEEE Computer Society Annual Symposium on VLSI (ISVLSI), pages 238–244. IEEE, 2018. [44] Masood Qazi, Amerasekera Ajith, and Anantha P. Chandrakasan. A 3.4pj feram-enabled d ﬂip-ﬂop in 0.13m cmos for nonvolatile processing in digital systems. In 2013 IEEE International Solid-State Circuits Conference Digest of Technical Papers. IEEE, 2013. [45] Farheen Fatima Khan and Andy Ye. A study on the accuracy of minimum width transistor area in estimating fpga layout area. Microprocessors and Microsystems, 52:287–298, 2017. [46] Srihari Cadambi, Abhinandan Majumdar, Michela Becchi, Srimat Chakradhar, and Hans Peter Graf. A programmable parallel accelerator for learning and classiﬁcation.", "page": 18, "position": 1}
