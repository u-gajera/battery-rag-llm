{"chunk_id": "2002.02094v1_p0_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs XINYI ZHANG, University of Pitsburgh CLAY PATTERSON, Oklahoma State University YONGPAN LIU, Tsinghua University CHENGMO YANG, University of Delaware CHUN JASON XUE, City University of Hong Kong JINGTONG HU, University of Pitsburgh Energy harvesting is an atractive way to power future IoT devices since it can eliminate the need for batery or power cables. However, harvested energy is intrinsically unstable. While FPGAs have been widely adopted in various embedded systems, it is hard to survive unstable power since all the memory components in FPGA are based on volatile SRAMs. Te emerging non-volatile memory based FPGAs provide promising potentials to keep conï¬guration data on the chip during power outages. Few works have considered implementing eï¬ƒcient runtime intermediate data checkpoint on non-volatile FPGAs. To realize accumulative computation under intermitent power on FPGA, this paper proposes a low-cost design framework, Data-Flow-Tracking FPGA (DFT-FPGA), which utilizes binary counters to track intermediate data ï¬‚ow. Instead of keeping all on-chip intermediate data, DFT-FPGA only targets on necessary data that is labeled by oï¬€-line analysis and identiï¬ed by an online tracking system. Te evaluation shows that compared with state-of-the-art techniques, DFT-FPGA can realize accumulative computing with less oï¬€-line workload and signiï¬cantly reduce online roll-back time and resource utilization. Tis paper has been accepted by ACM Journal on Emerging Technologies in Computing Systems (JETC). CCS Concepts: â€¢Computer systems organization â†’Embedded systems; Redundancy; Robotics; â€¢Networks â†’Network reliabil- ity; Additional Key Words and Phrases: energy harvesting, non-volatile FPGA, checkpoint, high-level-synthesis, data ï¬‚ow ACM Reference format: Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu. 2019. Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs. ACM Trans. Graph. 0, 0, Article 0 ( 2019), 19 pages. DOI: 00.0000/0000000.0000000 1 INTRODUCTION FPGAs have been widely adopted in various embedded systems that are powered by bateries. However, in the emerging Internet of Tings (IoT)[1â€“3], which is full of tiny, cost-sensitive, and space constrained widgets, bateries are no longer an ideal power supply due to poor scalability, recharging and safety concerns. Out of all possible alternatives,", "page": 0, "position": 0}
{"chunk_id": "2002.02094v1_p0_c1", "doc_id": "2002.02094v1", "text": "Non-volatile FPGAs. ACM Trans. Graph. 0, 0, Article 0 ( 2019), 19 pages. DOI: 00.0000/0000000.0000000 1 INTRODUCTION FPGAs have been widely adopted in various embedded systems that are powered by bateries. However, in the emerging Internet of Tings (IoT)[1â€“3], which is full of tiny, cost-sensitive, and space constrained widgets, bateries are no longer an ideal power supply due to poor scalability, recharging and safety concerns. Out of all possible alternatives, energy Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for proï¬t or commercial advantage and that copies bear this notice and the full citation on the ï¬rst page. Copyrights for components of this work owned by others than ACM must be honored. Abstracting with credit is permited. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior speciï¬c permission and/or a fee. Request permissions from permissions@acm.org. Â© 2019 ACM. Manuscript submited to ACM Manuscript submited to ACM 1 arXiv:2002.02094v1 [cs.AR] 6 Feb 2020", "page": 0, "position": 1}
{"chunk_id": "2002.02094v1_p1_c0", "doc_id": "2002.02094v1", "text": "2 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu harvesting systems are becoming one of the most promising candidates because they convert ambient energy from their surroundings. Some of the widely known energy harvesting techniques include Photovoltaics (PV), Termoelectric generators (TEGs), and Piezoelectric (PZ). A device equipped with these harvesters can utilize the converted energy directly or recharge its energy storage (e.g. capacitors). Te ease of access to power makes it a very competitive power source for portable devices. However, there are two primary challenges for such energy harvesting systems: unstable power and low power input. Even though there are ultra-low power FPGAs such as the Latice iCE40 series, which can work in ÂµW [4], the unpredictability of available energy renders the power intermitent which will interrupt computations. Te intermitent power will interrupt computations. In such a condition, long computations may be prohibited since the intermediate data will be lost and the computation has to start over from the beginning. Tus, it is essential to preserve the FPGA conf iĞ´uration data and intermediate data during a power outage. Conf iĞ´uration data keeps the functionality of a FPGA chip and intermediate data is the data generated during computation. By keeping both, long computations can be achieved by retrieving a checkpoint afer power resumes. Te non-volatile memory based FPGAs (NV-FPGAs) are natural candidates to address this challenge. With the substitution of NVMs such as ReRAM, STT-RAM, and PCM for SRAMs, conf iĞ´uration data can be retained locally on the chip with beneï¬ts of low leakage power, short critical path, and small area, etc [5â€“10]. Terefore, costs associated with loading conf iĞ´uration data from oï¬€-chip ï¬‚ash memories are avoided when FPGA recovers from a power outage. In the existing NV-FPGAs and traditional FPGAs, intermediate data is held by registers which consist of volatile ï¬‚ip-ï¬‚ops (FF). Like conf iĞ´uration data, intermediate data needs to be saved during power is lost or weak in order to resume system state afer the power comes back. To reserve intermediate data, non-volatile ï¬‚ip-ï¬‚ops (NV-FFs) have been integrated on processors. Such non-volatile processor", "page": 1, "position": 0}
{"chunk_id": "2002.02094v1_p1_c1", "doc_id": "2002.02094v1", "text": "are avoided when FPGA recovers from a power outage. In the existing NV-FPGAs and traditional FPGAs, intermediate data is held by registers which consist of volatile ï¬‚ip-ï¬‚ops (FF). Like conf iĞ´uration data, intermediate data needs to be saved during power is lost or weak in order to resume system state afer the power comes back. To reserve intermediate data, non-volatile ï¬‚ip-ï¬‚ops (NV-FFs) have been integrated on processors. Such non-volatile processor freezes all registers data locally on the chip if it is shut oï¬€[11]. Te success of NV-FFs in processors makes it a good candidate for FPGA ï¬‚ip-ï¬‚op. However, FPGAâ€™s register resource is signiï¬cantly more than the processorâ€™s and FPGA resource utilization varies design to design. Freezing all registers on FPGA will waste rare energy in energy harvesting system. To improve eï¬ƒciency in preserving intermediate data and reducing the roll-back impact from power interrupt, this paper proposes DFT-FPGA, a data ï¬‚ow tracking methodology on FPGA via High-Level-Synthesis (HLS). As HLS takes sofware functions as inputs and compiles it to Register-Transfer-Level (RTL) design. DFT-FPGA builds data ï¬‚ow trackers for such functions and a control unit to parse trackersâ€™ status in HLS. With an oï¬„ine mapping of functions to trackers, DFT-FPGA can online track the intermediate data inside a function via a tracker. Ten, instead of all data, only a set of tracked intermediate data in registers will be locally stored in non-volatile ï¬‚ip-ï¬‚ops. In this way, the cost to preserve intermediate data can be signiï¬cantly reduced. Te main contributions of this work are as follows: â€¢ Design of binary counter based tracker framework which tracks data ï¬‚ow in FPGA. â€¢ Design of control unit which stores the mapping of intermediate data and its on-chip physical address. â€¢ Design of an oï¬€-line intermediate data to tracker mapping algorithm. â€¢ Design of function split and merge method for DFT-FPGA. â€¢ A demonstration of the performance of NV-FF based FPGA. â€¢ A demonstration of the eï¬ƒciency of FPGA design on representative benchmarks. Te rest of the paper is organized as follows. Section 2 presents FPGA in an energy harvesting system, non-volatile FPGA, High-Level-Synthesis, and the", "page": 1, "position": 1}
{"chunk_id": "2002.02094v1_p2_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 3 2 PRELIMINARY We will ï¬rst present FPGA in an energy harvesting system in subsection 2.1. Ten works related to NV-FPGA and NV-FF architecture will be presented in subsection 2.1.1. Te background of High-Level-Synthesis will be introduced in subsection 2.2 and the motivation of the proposed work will be presented in subsection 2.3. 2.1 FPGA and Energy Harvesting System FPGA is widely adopted in open ï¬eld applications such as wireless network platforms [12â€“14]. In this application scenario, the energy harvesting system outperforms other resources such as batery and cable thanks to its perpetual power supply. In energy harvesting systems, ambient energy such as solar, wind, mechanical strain, ambient radiation, and human motion can be harvested to power the energy consumer and its peripheral devices. Tough energy harvesting can provide a perpetual power supply, when compared to systems powered by cable, energy harvesting system may only harvest and supply a small amount of energy. Moreover, the passive energy harvesting approach makes the harvested energy unpredictable and unreliable. It is observed that small harvesters such as a wrist-worn motion harvester can provide about 40 ÂµW power with worst-case power outages every 10ms in daily activities [15, 16]. Terefore, a device with the energy harvesting system should not only be able to work in a low-energy mode but also be robust enough under intermitent power. An energy harvesting system usually consists of an energy source, regulator, capacitor, and energy consumer. A classical system is shown in Fig. 1. Te regulator is a bridge between ambient energy, energy consumer, and an auxiliary capacitor. Energy consumer is powered by the regulator when harvested energy is suï¬ƒcient. Meanwhile, the capacitor is fully charged and standby for energy spike or power outage/weak. If the ambient energy becomes weak, the additional energy from capacitor should sustain the consumerâ€™s rest of work or preserve its current state. As the computation complexity varies from application to application, the energy needed for each application are diï¬€erent. Terefore, preserving the current states are widely adopted in designs [17â€“19, 19â€“24]. Moreover, the", "page": 2, "position": 0}
{"chunk_id": "2002.02094v1_p2_c1", "doc_id": "2002.02094v1", "text": "is suï¬ƒcient. Meanwhile, the capacitor is fully charged and standby for energy spike or power outage/weak. If the ambient energy becomes weak, the additional energy from capacitor should sustain the consumerâ€™s rest of work or preserve its current state. As the computation complexity varies from application to application, the energy needed for each application are diï¬€erent. Terefore, preserving the current states are widely adopted in designs [17â€“19, 19â€“24]. Moreover, the energy from capacitors is limited as the size of capacitors in small scale energy harvesting system can be as small as ÂµF and under 5v [19]. For energy consumers like microcontroller, ASIC, and FPGA, their dynamic power varies from cycle to cycle. Evaluating and recording the energy from each cycle to the end can be unrealistic as a regular application can be thousands or even dozens of thousands cycles. Ambient Energy Voltage regulator Energy Consumer Auxiliary Capacitor Fig. 1. An energy harvesting system. 2.1.1 FPGA architecture. A basic FPGA architecture consists of Conï¬gurable Logic Blocks (CLB), Block RAMs (BRAMs), Connect Boxes (CB), Switch Boxes (SB), and Routing Channels which is shown in Fig. 2. Each CLB is an independent computation group and computation results are transmited via Routing Channels. Switch Boxes redirect the data in Routing Channels to horizontal or vertical channels. BRAMs in FPGA serve as long-term massive data storage during computing. In this way, a CLB can reach any other CLB in FPGA. Computation results can be stored in BRAMs. Te breakdown structure of a CLB from Xilinx FPGA is shown in Figure 3 (a). Look Up Table (LUT) is the Manuscript submited to ACM", "page": 2, "position": 1}
{"chunk_id": "2002.02094v1_p3_c0", "doc_id": "2002.02094v1", "text": "4 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu smallest programmable computation unit inside a CLB which is wrapped by Basic Logic Element (BLE). As shown in this 4-input LUT, the LUT can have diï¬€erent logic by changing its mask binary order; diï¬€erent combinations of inputs will lead to diï¬€erent results in logic. Each LUT is followed by two ï¬‚ip-ï¬‚ops in a BLE which compose registers to support sequential logic in high-frequency computation. Te registers hold the intermediate results from LUTs in each clock cycle. Ten, data is sent out of CLB by Connect Box and this data is routed through Switch Boxes and Routing Channels. For a speciï¬c application, according to its complexity, a number of LUTs, ï¬‚ip-ï¬‚ops, Switch Boxes, and Routing Channels are selected and activated in FPGA to build its corresponding computation logic and data ï¬‚ow path. (In Xilinx FPGA, a CLB shown in Fig 3 (a) is named as SLICE and two SLICEs form a physical CLB) For traditional FPGA, SRAMs are used to build all these components. SRAMs are usually fast but volatile. Tus, the intrinsic ï¬‚exibility in reconï¬guring makes an FPGA easily switch between applications. However, conï¬guring data and computation data is vanishing from the chip when power is lost or weak. In order to keep the data, part of the FPGA components need to be replaced by non-volatile memory. CLB CB CB C B C B CLB CB CB C B C B B R A m CLB CB CB C B C B CLB CB CB C B C B B R A m CLB CB CB C B C B CLB CB CB C B C B CLB CB CB C B C B CLB CB CB C B C B SB SB SB Fig. 2. An overview of FPGA architecture. (a) Configurable Logic Block Crossbar Connections BLE BLE BLE BLE BLE LUT FF FF A B C D 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 CLB CLB CLK Master Latch D Slave Latch NVM Control", "page": 3, "position": 0}
{"chunk_id": "2002.02094v1_p4_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 5 2.1.2 Non-volatile FPGA. Te study of non-volatile FPGA has been conducted by Gaillardon, Cong, et, al [25â€“31]. Te existing NV-FPGAs preserve all conï¬guration data on the chip. As the conï¬guration data for LUT, Connect Boxes, and Switch Boxes are stored in SRAMs bit by bit, by replacing conï¬guration data SRAMs with non-volatile memories (NVMs) such ReRAM and STT-RAM, the conï¬guration data can be permanently retained on FPGA. Tough NVMs writing and reading speed is slower than SRAMs, it can preserve its data even power is lost. Figure. 3 shows how the conï¬guration data SRAMs are replaced by NVMs on-chip [25]. In this ï¬gure, a SRAM is represented by a grey block and an NVM is represented by the green block. Te LUT conï¬guration data is stored in its mask which is held by SRAMs. Afer replacing the SRAMs in the mask with NVMs, conï¬guration data for LUT can be permanently preserved on chip afer one programming. Figure. 3 (b) and (c) show how to preserve Connect Boxes and Switch Boxes conï¬guration data with NVMs. For Switch Boxes, afer conï¬guring all control SRAMs on the connections between horizontal and vertical tracks, data paths inside Routing Channels are formed. For Connect Boxes, a SRAM determines the on/oï¬€of a path between a CLB and a track. Afer conï¬guring all needed Switch Boxes and Connect Boxes, multiple data routing paths are formed. Afer adopting NVMs, the routing paths in FPGA can also be preserved. Tus, the conï¬guration data for an application can be preserved on-chip even power is oï¬€. Afer programming once, these NVMs can keep all conï¬gurations on-chip which avoids duplicate programming for the same program. SRAM based BRAMs in FPGA can also be directly replaced with non-volatile BRAMs (NV-BRAM). BRAMs are usually working as long-term massive storage on-chip. STT-MRAM based BRAMs (NV-BRAM) are proposed by Ju, et, al [31]. Compared with SRAM BRAMs, NV-BRAMs have higher density and smaller area. When substituting an SRAM with an NVM cell, six transistors are replaced with one NVM cell. Tus, for Switch Boxes,", "page": 4, "position": 0}
{"chunk_id": "2002.02094v1_p4_c1", "doc_id": "2002.02094v1", "text": "programming for the same program. SRAM based BRAMs in FPGA can also be directly replaced with non-volatile BRAMs (NV-BRAM). BRAMs are usually working as long-term massive storage on-chip. STT-MRAM based BRAMs (NV-BRAM) are proposed by Ju, et, al [31]. Compared with SRAM BRAMs, NV-BRAMs have higher density and smaller area. When substituting an SRAM with an NVM cell, six transistors are replaced with one NVM cell. Tus, for Switch Boxes, Connect Boxes, LUTs, and BRAMs, they can have a smaller area and be closer to each other in physical distance. In this way, the physical data routing distance is reduced, bringing additional beneï¬ts such as higher working frequency and more energy eï¬ƒciency. Furthermore, NVMs are compatible with CMOS technology via back-end-of-line technique [32]. By growing the NVM cells on the top of the chip, it adds non-volatility to an FPGA without increasing chip area and further reduces the area of FPGA components. An NVM based fully functional FPGA architecture is proposed by Cong, achieving 5.18x area savings, 2.28x speedup and 1.63x power savings compared with regular FPGAs [26]. 2.1.3 Non-volatile flip-flops. For the intermediate data, it is usually held in registers which are consisted of ï¬‚ip-ï¬‚ops. Non-volatile ï¬‚ip-ï¬‚ops are proposed by Qazi, Bartling, et, al [11, 33â€“35]. Contrary to conï¬guration data, intermediate data are frequently refreshed and the data ï¬‚ip frequency can be hundreds of mega hertz (MHz). Tat is, at each clock cycle, the data in a register is refreshed. Terefore, the NVMs writing and reading time may bring delay which hinders the FPGA work frequency. It is observed that a 65nm technology based ReRAM NV-FF has achieved writing time as good as 4Âµs seconds and 46.2 pico joul per bit [11]. Meanwhile, a regular FPGA usually works at hundreds of MHz, i.e working under ns clock period. With such performance, if NVMs writing happens in NV-FF every clock cycle, the FPGA frequency may be degraded to dozens of MHz. Te architecture of NV-FF is shown in Fig. 3 (d). Based on a master-slave ï¬‚ip-ï¬‚op, two pieces of NVMs are integrated to its slave logic. By adding extra NVM", "page": 4, "position": 1}
{"chunk_id": "2002.02094v1_p4_c2", "doc_id": "2002.02094v1", "text": "per bit [11]. Meanwhile, a regular FPGA usually works at hundreds of MHz, i.e working under ns clock period. With such performance, if NVMs writing happens in NV-FF every clock cycle, the FPGA frequency may be degraded to dozens of MHz. Te architecture of NV-FF is shown in Fig. 3 (d). Based on a master-slave ï¬‚ip-ï¬‚op, two pieces of NVMs are integrated to its slave logic. By adding extra NVM control part, data in slave logic can be optionally stored into or retrieved from NVM cell. It works like regular ï¬‚ip-ï¬‚op if NVM writing is not triggered and it can write the data to NVMs or recover data from NVM with a trigger. When writing to NVM is triggered, the clock will be hung and data is writen to NVM and vice versa. Tis avoids the writing to NVMs every clock cycle and the working frequency is not inï¬‚uenced if NVM writing is not triggered. Te NVM brings non-volatility but also larger logic area. It is observed in [11] that a NV-FF based processor has an extra 39% area for a single FF but less than 10% extra area for the whole chip. Te 39% single FF Manuscript submited to ACM", "page": 4, "position": 2}
{"chunk_id": "2002.02094v1_p5_c0", "doc_id": "2002.02094v1", "text": "6 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu area overhead is brought by the NVMâ€™s control logic and the NVM is growing on the top of the chip, which wonâ€™t bring extra area. Tough NVM writing is not triggered at every clock cycle, the area overhead from the control logic will increase its intrinsic delay and the size of a CLB, leading to bigger FPGA size, which increases the routing distance. Tis may decrease the FPGA working speed. Te impacts on FPGAs working frequency afer bringing in NV-FF is evaluated in section 5. For each NV-FF, it can be triggered to work as regular, store, or retrieve mode. If other FPGA components are non-volatile, by storing the intermediate data to the NVM if power is weak, the chip state can be held on board and be retrieved later. However, selecting a single ï¬‚ip-ï¬‚op in an FPGA chip is not accessible as a single ï¬‚ip-ï¬‚op can not be indexed inside a CLB. Moreover, FPGAâ€™s ï¬‚ip-ï¬‚op resource can number in the thousands and tens of thousands. In the proposed design, selected ï¬‚ip-ï¬‚ops need to be stored in order to keep intermediate data and ï¬‚ip-ï¬‚op storing and retrieve are executed SLICE by SLICE. Tis is due to FPGA tools like Vivado packing ï¬‚ip-ï¬‚ops into the same SLICE [36]. A physical CLB in Xilinx FPGA contains two SLICEs and each SLICE can be indexed on the chip. In general, 4 LUTs and 8 ï¬‚ip-ï¬‚ops or 8 LUTs and 16 ï¬‚ip-ï¬‚ops are placed in a SLICE. Terefore, the ï¬‚ip-ï¬‚op write and retrieve are triggered SLICE by SLICE in the proposed design. In DFT-FPGA, the SLICE addresses are acquired afer FPGA synthesis and pre-loaded to FPGA. During online intermediate data tracking, such SLICE addresses can be read out afer parsing trackersâ€™ status. Ten, the ï¬‚ip-ï¬‚ops in these SLICEs can be triggered in writing or retrieving. 2.2 High-Level-Synthesis (HLS) High-Level-Synthesis converts sofware language such as C/C++ to Hardware Description Language (HDL) like Verilog and VHDL. HLSâ€™s eï¬ƒciency and accuracy has been veriï¬ed in modern FPGA applications [37â€“40]. It takes sofware", "page": 5, "position": 0}
{"chunk_id": "2002.02094v1_p5_c1", "doc_id": "2002.02094v1", "text": "afer FPGA synthesis and pre-loaded to FPGA. During online intermediate data tracking, such SLICE addresses can be read out afer parsing trackersâ€™ status. Ten, the ï¬‚ip-ï¬‚ops in these SLICEs can be triggered in writing or retrieving. 2.2 High-Level-Synthesis (HLS) High-Level-Synthesis converts sofware language such as C/C++ to Hardware Description Language (HDL) like Verilog and VHDL. HLSâ€™s eï¬ƒciency and accuracy has been veriï¬ed in modern FPGA applications [37â€“40]. It takes sofware functions F as inputs to generate HDL modules M and state transition ï¬‚ow S. Afer HLS, a program is split into multiple modules according to program hierarchy. Tese modules are interpreted as diï¬€erent states in the state transition control. State transition control initializes and terminates the modules during FPGA operation. In HLS, each function under top function is generally compiled to a standalone module. Based on the data dependency between modules (functions), these modules are triggered in parallel or sequential in state transition control. A basic HLS FPGA design with its data ï¬‚ow control is shown in Fig. 4 [41]. In this program, there are three functions F1, F2 and F3 under top function Fmain. Afer HLS, functions are converted to modules as shown in Fig. 4 (a). In the top function, F1 and F2 have data dependency and F3 is independent of F1 and F2. Terefore, as shown in Fig. 4 (b) state transition control , F2 has to be placed afer F1 in state ï¬‚ow S. Meanwhile, F3 can start with F1. In states S1, S2 and S3, component information in module M1, M2 and M3 such as module names, registers, connections, and cycles can be collected. An unroll of S2 is shown in Figure. 4 (c). For HLS tools like Vivado/LegUp, it maps module components to diï¬€erent clock cycles and indicates the data ï¬‚ow among clock cycles. In the real case, a state like f2 may contain sub-state, each sub-state can be unrolled according to clock cycles. Afer High-Level-Synthesis, synthesis turns HDL into the implementation of logical gates, BRAMs, and registers. It also indicates the physical placement of all modules components. Afer implementation, these components are mapped", "page": 5, "position": 1}
{"chunk_id": "2002.02094v1_p6_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 7 ğ‘–ğ‘›ğ‘¡ğ‘šğ‘ğ‘–ğ‘›() { ğ‘–ğ‘›ğ‘¡ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3, ğ‘‘ğ‘ğ‘¡ğ‘4; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2 ; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3 ; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›3 ğ‘‘ğ‘ğ‘¡ğ‘4 ; } ğ‘šğ‘œğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘šğ‘ğ‘–ğ‘›(â€¦ ) { ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡â€¦; ğ‘œğ‘¢ğ‘¡ğ‘ğ‘¢ğ‘¡â€¦; ğ‘Ÿğ‘’ğ‘”â€¦; ğ‘šğ‘œğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 â€¦ ; ğ‘šğ‘œğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 â€¦ ; ğ‘šğ‘œğ‘‘ğ‘¢ğ‘™ğ‘’ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›3 â€¦ ; } ğ‘¡ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ ğ‘¡ğ‘’ğ‘›ğ‘‘ ğ‘¡ğ‘¥ ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘†1 ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 ğ‘†2 ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›3 ğ‘†3 ğ‘¡ğ‘¥ ğ‘¡ğ‘’ğ‘›ğ‘‘ resource list \\\\ â€¢ BRAM â€¢ LUT â€¢ Register â€¦ (a) Software functions to HDL (b) State transition (c) state 2 break down ğ‘œğ‘›ğ‘’ğ‘ğ‘™ğ‘œğ‘ğ‘˜ğ‘ğ‘¦ğ‘ğ‘™ğ‘’ Fig. 4. High-Level-Synthesis. SLICE addresses related to diï¬€erent registers are acquired. By online reading the status of trackers and parsing it to SLICE address, the SLICEs holding the intermediate data can be selected and saved. Te work ï¬‚ow of DFT-FPGA is shown in the Figure. 5. HLS ï¬rst generates the state transition and state components information. Tracker generation builds tracker framework accordingly. Afer tracker generation, the source function combined with tracker design are HLSed one more time. Ten, synthesis generates the executable bitstream and provides all SLICE address XxxYyy. Afer programming FPGA, DFT-FPGA pre-loads the SLICE addresses to FPGA and starts the computation. Te DFT-FPGA framework will be presented in Section 3 and the oï¬€-line analysis algorithm will be presented in Section 4. Software function High-level Synthesis Tracker Generation High-level Synthesis Synthesis Slice address extraction Bitstream load Slice addr load Fig. 5. DFT-FPGA work flow. 2.3 Motivation Existing designs preserve chip state by placing checkpoints in computation [17â€“19, 22â€“24, 42]. Azalia et al. propose Chime, which places checkpoints in Register-Transfer-Level (RTL) design. Chime oï¬€-line analyzes the forward com- puting cost and back-up overhead to determine checkpoint placement. By placing checkpoint in diï¬€erent locations, the computation can recover from a near checkpoint if a power outage happens. Yuan et al. propose CPâˆ’FPGA, a framework that based on HLS result. It places the diï¬€erent states of the main function in diï¬€erent BRAM-based (block RAM) physical areas by modifying FPGA synthesis algorithm. Each state result is stored in its dedicated BRAM and when power is lost in the mid of a state, the computation can start from its previous state. In the", "page": 6, "position": 0}
{"chunk_id": "2002.02094v1_p6_c1", "doc_id": "2002.02094v1", "text": "near checkpoint if a power outage happens. Yuan et al. propose CPâˆ’FPGA, a framework that based on HLS result. It places the diï¬€erent states of the main function in diï¬€erent BRAM-based (block RAM) physical areas by modifying FPGA synthesis algorithm. Each state result is stored in its dedicated BRAM and when power is lost in the mid of a state, the computation can start from its previous state. In the existing works, the intermediate data back-up is triggered at every checkpoint. Afer retrieving from a checkpoint, the computation can continue. While the prior strategies can successfully preserve the intermediate data, long roll-back can easily occur if power is lost in a long state. Tis case is shown in Fig. 6 (a), a dot represents the end of a state. Checkpoints are placed at each dot. For applications with a long state, such strategies may be hard to complete the computation if a power outage happens in the middle of a long state. Roll-back may occur several times inside a long state until power is stable. Moreover, by tying a state and a BRAM together, BRAM resources can be insuï¬ƒcient for a large program with multiple states, and periodical data back-up happens even if power is stable. Fig 6 (b) shows the performance comparison between proposed design and periodical checkpoint design; the red line shows checkpoint technology and the green line shows DFT-FPGA. Power outage happens at t3 and t7. Checkpoints Manuscript submited to ACM", "page": 6, "position": 1}
{"chunk_id": "2002.02094v1_p7_c0", "doc_id": "2002.02094v1", "text": "8 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu are placed at progress 20%, 40% and 60%. As checkpoints are pre-deï¬ned, data writing occurs at each checkpoint regardless of the power condition. Te computation starts from its previous checkpoint afer power loss. However, in DFT-FPGA, the checkpoint is avoided and data ï¬‚ow is always tracked. Tus, data back-up happens only if power is lost and computation starts from the progress where power breaks. Compared with DFT-FPGA, the existing checkpoint placement technologies for FPGA in energy harvesting system suï¬€er from long roll-back time, increasing the complexity of original program, and modifying the FPGA synthesis algorithm. Preserving the data for the entire chip may also be an option [11]. By triggering writing and retrieving of ï¬‚ip-ï¬‚ops in all FPGA SLICEs, all the data on chip can be fully reserved. However, such strategy can be heavily resource intensive. As FPGA resource utilization varies from design to design, preserving the entire chip causes unnecessary NVM cell writing in unused memories, which will waste rare harvested energy and slow down the writing speed. As it is shown in Figure. 6 (c), this computation only occupies 15% of the chip resource, the remaining 85% components are still stored and retrieved if preserving the whole chip data. Afer applying DFT-FPGA, unnecessary back-up can be avoided. Te beneï¬ts and impact afer applying DFT-FPGA will be presented in section 5. Our previous work FC-FPGA applies shif-register like data ï¬‚ow tracker to locate and retrieve intermediate data in RTL level [43]. In this work, binary counters are adopted to further reduce resource utilization and a full High-Level-Synthesis based work ï¬‚ow is proposed, which signiï¬cantly reduces the workload. (a) Long state with power lost (b) Periodical checkpoint and DFT-FPGA (c) Hold all data on-chip start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 40 20 60 80 100 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 Time Power Periodical checkpoint DFT-FPGA with power failure Checkpoint time Roll-back time Progress (%) Fig. 6. The motivation example. 3 DFT-FPGA FRAMEWORK", "page": 7, "position": 0}
{"chunk_id": "2002.02094v1_p7_c1", "doc_id": "2002.02094v1", "text": "reduces the workload. (a) Long state with power lost (b) Periodical checkpoint and DFT-FPGA (c) Hold all data on-chip start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 start end ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘› ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘›+1 40 20 60 80 100 t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 Time Power Periodical checkpoint DFT-FPGA with power failure Checkpoint time Roll-back time Progress (%) Fig. 6. The motivation example. 3 DFT-FPGA FRAMEWORK Te proposed DFT-FPGA methodology includes both framework and data-to-tracker mapping algorithm designs. In this section, we will introduce the framework of DFT-FPGA. Te algorithms that work with the framework will be introduced in Section 4. 3.1 Hardware Architecture Overview Te proposed design includes function trackers f and NV-FF control unit CU which is shown in Figure 8 (b). In this ï¬gure, a ï¬nite state machine is generated by HLS in the back-end to control data transition in functions, i.e. state transition between states. Each function is assigned a function tracker. Trackers are read by the control unit which pre-loads SLICE addresses and maps them to associated registers. In DFT-FPGA, at every power outage, the control unit reads function trackerâ€™s status and then select the corresponding SLICE to trigger action. In the proposed design, the control path to NV-FF control part is considered already embedded in NV-FPGA. Manuscript submited to ACM", "page": 7, "position": 1}
{"chunk_id": "2002.02094v1_p8_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 9 3.2 Function Trackers As all intermediate data is held by registers, function trackers are designed to track the active registers at each clock cycle. Terefore, a tracker is built to have the same clock cycles with its corresponding function. By reading trackerâ€™s status, the data ï¬‚ow location in its function can be acquired. In DFT-FPGA, each function is assigned a function tracker to trace its data ï¬‚ow. Te tracker is activated simultaneously with its corresponding function and they are terminated at the same time. Te method to insert trackers to a sofware program is shown in Figure. 7 (a). Functions F1, F2, and F3 under Fmain are assigned private trackers f1, f2, and f3. Te state transition and timing among F1âˆ’3 is as it is illustrated in Fig. 4 (b). Terefore, the initialization of trackers f1âˆ’3 should also follow such orders. In the proposed design, lock is utilized between trackers to keep trackers initialized in the right order. Te lock in a tracker consists lockhead and locktail. If a tracker is initialized afer its anterior tracker, its lockhead is the locktail of the anterior tracker. As shown in Fig. 7 (c), tracker f2â€²s lock2head is f1â€²s lock1tail . Afer tracker f1 is terminated, lock1tail is set to be 1. Tus, tracker f2 is always blocked if F1 and f1 are not ï¬nished. As there is no data dependency between function F1 and tracker f1, f1 can start with function F1 simultaneously. For trackers which start with the beginning function, such as f1, its lock1head is pre-deï¬ned to be 1 to unblock itself. In this way, all trackers can be initialized and terminated with their corresponding functions. A function tracker consists of loop arbitration t, binary counter count, tracker status register fstatus, and tracker lock lockhead locktail. Without loss of generality, trackers can track function with loops or with regular operations. An example of a function and its tracker logic is shown in Fig. 7 (b) and (c). Tis is a function with an outer loop and an inner", "page": 8, "position": 0}
{"chunk_id": "2002.02094v1_p8_c1", "doc_id": "2002.02094v1", "text": "be initialized and terminated with their corresponding functions. A function tracker consists of loop arbitration t, binary counter count, tracker status register fstatus, and tracker lock lockhead locktail. Without loss of generality, trackers can track function with loops or with regular operations. An example of a function and its tracker logic is shown in Fig. 7 (b) and (c). Tis is a function with an outer loop and an inner loop. In the tracker, the ï¬rst loop t handles functions with loops. Loop iterations t corresponds to the outer loop iteration number in a function. Countmax is the length of all operations under functionâ€™s outer loop. Te binary counter increments to countmax and then be reset to zero for the next outer loop iteration. Tus, the binary counter can be reused in all outer loop iterations. If a function does not contain any loop, t is set to one and countmax is the length of the function. When power is lost during computing, the energy harvesting system sends Ploss = 1 to DFT-FPGA. With Ploss |resume = 1, the tracker sends out its status count as fstatus. Trackersâ€™ fstatus will be further parsed by control unit. When reaching the end of tracking, the fstatus is reset to zero. In this way, the tracker can count with the function process and send out the process stage when power is loss. Afer power resumes Presume, trackers data is recovered by NV-FPGA ï¬rst and the resumed trackersâ€™ status are utilized to wake up the stored intermediate data. To further reduce the binary size, the binary counter can be deï¬ned to lower bit-width such as 4bit, 8bit, and 16bit according to the length of a function. In most cases, the binary counter size is found to be small as 4-8 bit (tracking length ranges 225-65025 cycles). Te resource utilization, tracking length, and performance of trackers in diï¬€erent sizes will be discussed in section 5. 3.3 NV-FF Control Unit Te control unit read all trackersâ€™ status fstatus. As trackersâ€™ status is cycle accurate, by keeping the active register SLICE address for each clock cycle in", "page": 8, "position": 1}
{"chunk_id": "2002.02094v1_p8_c2", "doc_id": "2002.02094v1", "text": "a function. In most cases, the binary counter size is found to be small as 4-8 bit (tracking length ranges 225-65025 cycles). Te resource utilization, tracking length, and performance of trackers in diï¬€erent sizes will be discussed in section 5. 3.3 NV-FF Control Unit Te control unit read all trackersâ€™ status fstatus. As trackersâ€™ status is cycle accurate, by keeping the active register SLICE address for each clock cycle in control unit, DFT-FPGA can acquire the physical location of intermediate data ï¬‚ow. Such address can then be utilized by NV-FPGA to have SLICE registers data stored of retrieved. Te control unit also keeps the mapping relations of function trackers status and registersâ€™ SLICE address. It consists of one or multiple BRAMs and address look-up logic as shown in Figure. 8 (a). All associated SLICE addresses for trackers are pre-loaded to cuBRAM with index fstatus+of f set. O f f set works as index boundary in cuBRAM when a new tracker is generated. And each cuBRAM[of f set] is pre-set to zero. Tus, each tracker can have a certain range Manuscript submited to ACM", "page": 8, "position": 2}
{"chunk_id": "2002.02094v1_p9_c0", "doc_id": "2002.02094v1", "text": "10 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu (a) Functions and trackers (b) Function 2 (c) Tracker ğ‘“2 logic ğ‘–ğ‘›ğ‘¡ğ‘šğ‘ğ‘–ğ‘›() { ğ‘–ğ‘›ğ‘¡ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3, ğ‘‘ğ‘ğ‘¡ğ‘4; ğ‘ğ‘œğ‘œğ‘™ğ‘™ğ‘œğ‘ğ‘˜1â„ğ‘’ğ‘ğ‘‘= 1; ğ‘ğ‘œğ‘œğ‘™ğ‘™ğ‘œğ‘ğ‘˜3â„ğ‘’ğ‘ğ‘‘= 1; ğ‘ğ‘œğ‘œğ‘™ğ‘™ğ‘œğ‘ğ‘˜1ğ‘¡ğ‘ğ‘–ğ‘™, ğ‘™ğ‘œğ‘ğ‘˜3ğ‘¡ğ‘ğ‘–ğ‘™,ğ‘™ğ‘œğ‘ğ‘˜2ğ‘¡ğ‘ğ‘–ğ‘™; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2 ; ğ‘–ğ‘›ğ‘¡ğ‘“1() ; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3 ; ğ‘–ğ‘›ğ‘¡ğ‘“2() ; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›3 ğ‘‘ğ‘ğ‘¡ğ‘4 ; ğ‘–ğ‘›ğ‘¡ğ‘“3() ; } ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘  . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘  } ğ‘–ğ‘›ğ‘¡ğ‘“2() { ğ‘–ğ‘›ğ‘¡ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= 0 , ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = 0; ğ’Šğ’‡ğ‘™ğ‘œğ‘ğ‘˜1ğ‘¡ğ‘ğ‘–ğ‘™= 1 \\\\ ğ‘¡ğ‘ğ‘ğ‘›ğ‘ğ‘’1 ğ’‡ğ’ğ’“ğ‘–= 1 ğ‘¡ğ‘œğ‘¡ ğ’˜ğ’‰ğ’Šğ’ğ’†ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡< ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ğ‘šğ‘ğ‘¥ ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡+ 1 ğ’Šğ’‡ğ‘ğ‘™ğ‘œğ‘ ğ‘ = 1 || ğ‘resume = 1 ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= 0 ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = 0 ğ‘™ğ‘œğ‘ğ‘˜2ğ‘¡ğ‘ğ‘–ğ‘™= 1 } Fig. 7. Tracker design and asignment in HLS ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘˜ğ‘’ğ‘Ÿ1 ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘ğ‘ğ‘˜ğ‘’ğ‘Ÿğ‘› ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘› ğ‘“ğ‘–ğ‘›ğ‘–ğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘’ğ‘šğ‘ğ‘â„ğ‘–ğ‘›ğ‘’ ğ‘ğ‘‰âˆ’ğ¹ğ¹ğ‘ğ‘œğ‘›ğ‘¡ğ‘Ÿğ‘œğ‘™ğ‘¢ğ‘›ğ‘–ğ‘¡ ğ¹ğ‘ƒğºğ´ğ‘â„ğ‘–ğ‘ (a) NV-FF control unit (b) Design overview (c) Control unit data struct ğ‘–ğ‘›ğ‘¡ğ‘“1_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ , ğ‘“2_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ , ğ‘“3_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ; ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¢ğ‘ğ‘¢_ğµğ‘…ğ´ğ‘€[ğ‘ğ‘¢_ğ‘‘ğ‘’ğ‘ğ‘¡â„]; ğ‘–ğ‘›ğ‘¡ğ‘“1_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ, ğ‘“2_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ, ğ‘“3_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ; ğ‘–ğ‘›ğ‘¡ğ‘šğ‘ğ‘–ğ‘›_ğ‘ğ‘¢() { //address offset to ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ if in same BRAM ğ‘“1_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ= ğ‘ğ‘¢_ğµğ‘…ğ´ğ‘€[ğ‘“1_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ + ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡1]; ğ‘“2_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ= ğ‘ğ‘¢_ğµğ‘…ğ´ğ‘€[ğ‘“2_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ + ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡2]; ğ‘“3_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ= ğ‘ğ‘¢_ğµğ‘…ğ´ğ‘€[ğ‘“3_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ + ğ‘œğ‘“ğ‘“ğ‘ ğ‘’ğ‘¡3]; } ğ‘¡ğ‘¦ğ‘ğ‘’ğ‘‘ğ‘’ğ‘“ğ‘ ğ‘¡ğ‘Ÿğ‘¢ğ‘ğ‘¡{ ğ‘–ğ‘›ğ‘¡ğ‘ ğ‘™ğ‘–ğ‘ğ‘’_ğ‘¥; ğ‘–ğ‘›ğ‘¡ğ‘ ğ‘™ğ‘–ğ‘ğ‘’_ğ‘¦; }ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¢; ğ‘–ğ‘›ğ‘¡ğ‘“1_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ , ğ‘“2_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ , ğ‘“3_ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ ; ğ‘‘ğ‘ğ‘¡ğ‘_ğ‘ğ‘¢ğ‘ğ‘¢_ğµğ‘…ğ´ğ‘€[ğ‘ğ‘¢_ğ‘‘ğ‘’ğ‘ğ‘¡â„]; ğ‘–ğ‘›ğ‘¡ğ‘“1_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ, ğ‘“2_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ, ğ‘“3_ğ‘Ÿğ‘’ğ‘”ğ‘ğ‘‘ğ‘‘ğ‘Ÿ; . . . . . . . . . Fig. 8. Control Unit and DFT-FPGA overview. of storage in cuBRAM. In this ï¬gure, all trackers fstatus is combined with oï¬€set including the ï¬rst tracker f1. Tis is because trackers themselves in DFT-FPGA are needed to be reserved as well, cuBRAM keeps trackers SLICE address with index zero to of f set1. Te SLICEs where trackers are placed are always stored when power is lost. By online reading fstatus, corresponding SLICE addresses are parsed by the control unit. SLICE storing or retrieving can then be operated on these SLICEs. As tracker fstatus is zero if it is not triggered or terminated, no action to SLICEs will be executed for such trackers and the control unit will parse zero addresses. In DFT-FPGA, one BRAM cuBRAM is instantiated to keep all trackersâ€™ mapped SLICE addresses. During HLS, if the depth of the cuBRAM is too big to be placed in a single physical BRAM, the synthesis tool will automatically expand it", "page": 9, "position": 0}
{"chunk_id": "2002.02094v1_p9_c1", "doc_id": "2002.02094v1", "text": "As tracker fstatus is zero if it is not triggered or terminated, no action to SLICEs will be executed for such trackers and the control unit will parse zero addresses. In DFT-FPGA, one BRAM cuBRAM is instantiated to keep all trackersâ€™ mapped SLICE addresses. During HLS, if the depth of the cuBRAM is too big to be placed in a single physical BRAM, the synthesis tool will automatically expand it to multi-BRAM. As the SLICE address in FPGA is organized as Xxx Yyy, a data structure is used in DFT-FPGA to keep address in X and Y direction which is shown in Figure. 8 (c). Te resource utilization and performance of the control unit will be discussed in section 5. Afer assigning trackers to functions, there are two tasks that need to be accomplished before DFT-FPGA can work properly. First of all, for a given program with multiple functions, we need to identify which registers will keep intermediate data at a certain clock cycle in each function. Second, as tracker assignment is arranged according to function hierarchy, the main function should only contain the substantiation of functions. In this task, function merge and function split will be discussed. Manuscript submited to ACM", "page": 9, "position": 1}
{"chunk_id": "2002.02094v1_p10_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 11 4 DFT-FPGA OFF-LINE ANALYSIS In previous sections, we show how to generate and assign trackers to functions. In this section, we will present how to establish mappings between a function and its tracker, and how to merge or split functions in a program. 4.1 Function to Tracker Mapping Afer analyzing the program hierarchy and the state transition, the activation of trackers are determined. Te mapping of tracker status to data ï¬‚ow in a function can be determined by unrolling a functionâ€™s state. A state breakdown is shown in Figure. 9 (a). In this ï¬gure, rectangle blocks represent operations inside the function and they are arranged to clock cycles from tstart to tend. At each clock cycle tn, operations ptn with its register reĞ´tn are placed. Te connecting arrows indicate the data ï¬‚ow inside a state. In this ï¬gure, p2 and p3 are operations for ptn+2; reĞ´2 and reĞ´3 are registers for reĞ´tn+2. Every operation is followed by its register to get its data held at every clock cycle. For registers reĞ´tn in a state, they keep the intermediate data within a function at diï¬€erent clock cycles. Tose registers are the target to be tracked by trackers deï¬ned with checkpointtn . As diï¬€erent registers are triggered during the function process, registers that hold intermediate data for each clock cycle should be determined and those registersâ€™ SLICE addresses are stored by the control unit. In FPGA design, operations can execute in parallel like p2 and p3. And operations may have multi-cycle length such as p4. Terefore, at certain clock cycle, there can be multiple registers reĞ´tn or previous register reĞ´tnâ€² to hold the intermediate data. Te method to determine checkpointtn is illustrated in Algorithm 1. At each cycle tn, its register reĞ´tn is added to checkpointtn because its operations end at this cycle. If a multi-cycle operation is cross tn which starts at tnâ€² and ends at tnâˆ—, the reĞ´tnâ€² ahead of this operation is also added to checkpointtn , e.g, checkpointtn+2=reĞ´2 âˆª reĞ´3; checkpointtn+3=reĞ´2 âˆªreĞ´3. In this way, the", "page": 10, "position": 0}
{"chunk_id": "2002.02094v1_p10_c1", "doc_id": "2002.02094v1", "text": "to hold the intermediate data. Te method to determine checkpointtn is illustrated in Algorithm 1. At each cycle tn, its register reĞ´tn is added to checkpointtn because its operations end at this cycle. If a multi-cycle operation is cross tn which starts at tnâ€² and ends at tnâˆ—, the reĞ´tnâ€² ahead of this operation is also added to checkpointtn , e.g, checkpointtn+2=reĞ´2 âˆª reĞ´3; checkpointtn+3=reĞ´2 âˆªreĞ´3. In this way, the registers holding intermediate data for each clock cycle are acquired. For multi-cycle operation like p4 at tn+3, DFT-FPGA inserts roll-back logic to ensure the consistency between tracker and function afer retrieve. Te roll-back logic is shown in Fig. 9 (b). Afer applying Algorithm 1 to all functions and trackers, the mappings between registers to tracker status is established. If this is a loop function as indicated by the dashed line in Fig. 9 (a), tstart to tend is tracked by count and its loop iteration is controlled by t in tracker. Te same binary counter count will be called t times. In this way, DFT-FPGA can scale down the binary counter size and save more ï¬‚ip-ï¬‚op resources. By analyzing one iterationâ€™s mapping relation, the mapping for the whole function is acquired. During synthesis, these registersâ€™ SLICE address can be acquired. Afer that, the mappings between trackers status and SLICE address can be established. Ten, applying the mapping algorithm, registers are mapped to tracker. However, for registers barren computation, DFT-FPGA can choose to not assign tracker to if tracker ï¬‚ip-ï¬‚op resources are more than target registers. Such cases are studied in section 5. Afer analyzing the mapping between a tracker and its function, the trackers for the main function Fmain need to be arranged. Te proposed DFT-FPGA will tune the hierarchy of Fmain to make it suitable for tracker assignment. Te next task includes function split and function forming. 4.2 Function Split and Merge 4.2.1 Function Split. As sofware language is normally ï¬‚exible in hierarchy and coding style. A programâ€™s hierarchy may need to be tuned and then DFT-FPGA can be applied. A function needs to be split if there are", "page": 10, "position": 1}
{"chunk_id": "2002.02094v1_p11_c0", "doc_id": "2002.02094v1", "text": "12 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu Algorithm 1 Checkpointt determination Input: function state S, start point tstart , end point tend, operations ptn , registers reĞ´tn Output: checkpointt Deï¬ne: start < n < end, start < nâ€² < n, n < nâˆ—< end for tn âˆˆS do checkpointt .append(reĞ´tn ) for tnâ€² âˆˆS do for tnâˆ—âˆˆS do if reĞ´tnâ€² â™¦ptâˆ—= 1 then checkpointt .append(reĞ´tnâ€² ) \\\\â™¦ end if end for end for end for return checkpointt (a) A state with muli-cycle operation (b) Roll-back logic ğ‘–ğ‘›ğ‘¡ğ‘“2() { ğ‘–ğ‘›ğ‘¡ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= 0 , ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = 0; ğ’Šğ’‡ğ‘™ğ‘œğ‘ğ‘˜1ğ‘¡ğ‘ğ‘–ğ‘™= 1 \\\\ ğ‘¡ğ‘ğ‘ğ‘›ğ‘ğ‘’1 ğ’‡ğ’ğ’“ğ‘–= 1 ğ‘¡ğ‘œğ‘¡ ğ’˜ğ’‰ğ’Šğ’ğ’†ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡< ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ğ‘šğ‘ğ‘¥ ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡+ 1 ğ’Šğ’‡ğ‘ğ‘™ğ‘œğ‘ ğ‘ = 1 ğ’Šğ’‡ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= ğ‘¡ğ‘›+3 ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡âˆ’1 ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡ ğ‘ğ‘œğ‘¢ğ‘›ğ‘¡= 0 ğ‘“ğ‘ ğ‘¡ğ‘ğ‘¡ğ‘¢ğ‘ = 0 ğ‘™ğ‘œğ‘ğ‘˜2ğ‘¡ğ‘ğ‘–ğ‘™= 1 } ğ‘¡ğ‘› ğ‘¡ğ‘›+2 ğ‘¡ğ‘›+4 ğ‘¡ğ‘›+6 ğ‘1 ğ‘2 ğ‘3 ğ‘4 ğ‘5 ğ‘6 ğ‘7 ğ‘8 ğ‘¡ğ‘›+8 ğ‘¡ğ‘ ğ‘¡ğ‘ğ‘Ÿğ‘¡ ğ‘¡ğ‘’ğ‘›ğ‘‘ Fig. 9. A state breakdown and roll-back logic. its all inner operations, a function is split to multiple functions according to the number of independent loops. Ten, trackers will be assigned to split functions. If a function contains more than loop functions, the function needs to be split based on the boundaries between loop and other operations. A case where a loop is followed by other operations is shown in Fig. 10 (b). It needs to be split into two functions. Trough spliting functions, the proposed tracker logic can be successfully applied. 4.2.2 Function Merge. Under the main function, there can be operations between functions. As the state transition is arranged between functions, those non-function operations will be automatically merged into a function by HLS. Tis will cause obfuscation in function-to-tracker mapping and the auto-merged function cannot be directly applied with trackers. Such a case is shown in Fig 11. By wrapping these operations to a function, state transition can be arranged in diï¬€erent functions. Ten, trackers can be built and assigned to all tuned functions. 5 EXPERIMENT In this section, we ï¬rst evaluate the performance of FPGA architecture with NV-FF in subsection 5.1. Second, we evaluate the proposed tracker and control unit resource utilization and performance", "page": 11, "position": 0}
{"chunk_id": "2002.02094v1_p12_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 13 (a) Function split case 1 (b) Function split case 2 ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘1 ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘2 ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  } ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›21 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘1 ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  } ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›22 (){ \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘2 ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  } ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ğ‘  . . . . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘  } ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›21 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . ğ’‡ğ’ğ’“. . . \\\\ ğ‘œğ‘¢ğ‘¡ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘ ğ’‡ğ’ğ’“. . . \\\\ ğ‘–ğ‘›ğ‘›ğ‘’ğ‘Ÿğ‘™ğ‘œğ‘œğ‘} . . . ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›22 () { \\\\ğ‘‘ğ‘’ğ‘“ğ‘–ğ‘›ğ‘’ğ‘£ğ‘ğ‘Ÿğ‘–ğ‘ğ‘ğ‘™ğ‘’s . . . . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ } Fig. 10. Function split. ğ‘–ğ‘›ğ‘¡ğ‘šğ‘ğ‘–ğ‘›() { ğ‘–ğ‘›ğ‘¡ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2 ; . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ğ‘œğ‘‘ğ‘’ . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ğ‘œğ‘‘ğ‘’ . . . \\\\ ğ‘œğ‘ğ‘’ğ‘Ÿğ‘ğ‘¡ğ‘–ğ‘œğ‘›ğ‘ğ‘œğ‘‘ğ‘’ ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3 ; } ğ‘–ğ‘›ğ‘¡ğ‘šğ‘ğ‘–ğ‘›() { ğ‘–ğ‘›ğ‘¡ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1 ğ‘‘ğ‘ğ‘¡ğ‘1, ğ‘‘ğ‘ğ‘¡ğ‘2 ; ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›1_1(); ğ‘–ğ‘›ğ‘¡ğ‘“ğ‘¢ğ‘›ğ‘ğ‘¡ğ‘–ğ‘œğ‘›2 ğ‘‘ğ‘ğ‘¡ğ‘2, ğ‘‘ğ‘ğ‘¡ğ‘3 ; } Fig. 11. Function merge. subsection 5.3. Last we evaluate the performance comparison between the periodical checkpoint and the proposed design in subsection 5.4. In experiments, tool Verilog-To-Routing (VTR) is used in evaluating the FPGA architecture with NV-FF in subsection 5.1. Vivado HLS is used in remaining evaluations for analyzing and generating DFT-FPGA and analyzing benchmarks. Vivado is used in FPGA synthesis and geting all registers SLICE address. 5.1 NV-FF FPGA performance In this subsection, we base on FPGA architecture K6âˆ’f rac âˆ’N10âˆ’mem32K âˆ’40nm from VTR, by adding delay to its D ï¬‚ip-ï¬‚op module and increasing CLB area to evaluate the impact from NV-FFs. As presented in section 2.1.3, the control part in NV-FF brings extra area. Increasing the area of a single ï¬‚ip-ï¬‚op can degrade its timing performance but ï¬‚ip-ï¬‚op area size is not simulated in VTR. Terefore, we add extra delay to each single ï¬‚ip-ï¬‚op according to the area scaling up ratio 39% and 49% [11, 44]. Te", "page": 12, "position": 0}
{"chunk_id": "2002.02094v1_p12_c1", "doc_id": "2002.02094v1", "text": "its D ï¬‚ip-ï¬‚op module and increasing CLB area to evaluate the impact from NV-FFs. As presented in section 2.1.3, the control part in NV-FF brings extra area. Increasing the area of a single ï¬‚ip-ï¬‚op can degrade its timing performance but ï¬‚ip-ï¬‚op area size is not simulated in VTR. Terefore, we add extra delay to each single ï¬‚ip-ï¬‚op according to the area scaling up ratio 39% and 49% [11, 44]. Te extra 39% case is caused by additional 15T2R, which is 15 transistors and 2 ReRAMs [11]. Te extra 49% case is caused by additional 22T2R, which is 22 transistors and 2 ReRAMs [44]. Te increase of ï¬‚ip-ï¬‚op size also brings a larger CLB area, which will lead to longer routing distancedistance and may degrade FPGAâ€™s working frequency. In the evaluated FPGA architecture, each CLB contains 10 ï¬‚ip-ï¬‚ops. For the two types of NV-FF structure, due to VTR adopts minimum width transistor area [45] to deï¬ne the size of components, we increase the CLB size by 15 minimum width transistor area and 22 minimum width transistor area accordingly. Te FPGA architecture size increment is shown in Figure. 12 (a). In this ï¬gure, the blue column represents the base architecture, the orange column represents the 15T2R architecture, and the grey column represents the 22T2R architecture. We observe a 0.2% logic area increasing from base to 15T2R and 0.07% from 15T2R to 22T2R. Routing area increases 0.16% from base to 15T2R and 0.04% from 15T2R to 22T2R. Manuscript submited to ACM", "page": 12, "position": 1}
{"chunk_id": "2002.02094v1_p13_c0", "doc_id": "2002.02094v1", "text": "14 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu To evaluate the impact on FPGA working frequency which suï¬€ers from longer ï¬‚ip-ï¬‚op delay and routing distance, we apply seven benchmarks in VTR on three FPGA architectures, respectively. Te critical path delay and maximum working frequency are shown in Fig. 12 (b) and (c). In the evaluated benchmarks, we observe that 15T2R architecture causes less than 3% of additional critical path delay and 22T2R architecture causes less than 7.4% additional critical path delay compared to base architecture. As the critical path delay determined the maximum working frequency, we also show the maximum working frequency in Fig. 12 (c). We can observe that less than 6.5MHz degradation is caused by 15T2R and less than 10MHz is caused by 22T2R. From the evaluation, we can see that integrating NV-FF on FPGA brings a bit performance degradation, i.e, several MHz. However, as most designs running on FPGA work at hundreds of MHz [37, 39, 46, 47], such degradation has litle impact on overall performance and achieves non-volatility of ï¬‚ip-ï¬‚ops. ns MHz (a) NV-FF FPGA architecture area (b) Critical path delay (c) Maximum working frequency minimum width transistor area Regular 15T2R 22T2R Fig. 12. NV-FPGA performance. 5.2 Tracker and Control Unit Evaluation In the previous section, we evaluated the performance of NV-FF based FPGA architecture. In this section, we will evaluate the resource utilization and timing performance of DFT-FPGA framework. Te evaluation is based on FPGA chip xc7z020clĞ´484. Table 1 shows the ï¬‚ip-ï¬‚op, LUTs usages, and maximum tracking cycles when a tracker size scales from 4bit to 9bit. Te resource of xc7z020clĞ´484 is also listed. In the evaluation, we observe less than 0.03% of ï¬‚ip-ï¬‚ops and less than 0.21% LUTs are used to build a tracker. Similarly, less than 0.05% of ï¬‚ip-ï¬‚ops and less than 0.31% LUTs are used to build a control unit. If applying DFT-FPGA on large scale FPGAs, the utilization ratio will be further reduced. Te maximum tracking cycles are Max Cycle = t âˆ—countmax which is illustrated in in section 3.2. For example, 8-bit tracker", "page": 13, "position": 0}
{"chunk_id": "2002.02094v1_p13_c1", "doc_id": "2002.02094v1", "text": "observe less than 0.03% of ï¬‚ip-ï¬‚ops and less than 0.21% LUTs are used to build a tracker. Similarly, less than 0.05% of ï¬‚ip-ï¬‚ops and less than 0.31% LUTs are used to build a control unit. If applying DFT-FPGA on large scale FPGAs, the utilization ratio will be further reduced. Te maximum tracking cycles are Max Cycle = t âˆ—countmax which is illustrated in in section 3.2. For example, 8-bit tracker can count a function with up to 65025 = 255 âˆ—255 cycles. Te control unit keeps SLICE addresses and indexes it afer reading trackersâ€™ status. Te control unitâ€™s resource utilization is shown in Table 2. In this table, we show the resource of a control unit with one tracker when tracker size scales from 4bit to 9bit. A n bit counter needs countmax depth in BRAM to store SLICE address because the count start over when enter each iteration of t. Tus, the depth needed for a tracker is much smaller than the length of a function. When the counter is less than 8bit, Vivado HLS optimizes it into ï¬‚ip-ï¬‚ops and LUTs to save BRAM resource. Te timing performance of a DFT-FPGA framework is shown in Table 3. In this evaluation, we measure the maximum working frequency of 8-bit standalone tracker, standalone control unit, and DFT-FPGA which is an integration of one 8-bit tracker and control unit. We can observe that a standalone tracker can work up to 500MHz and a standalone control unit can work up to 400MHz on FPGA xc7z020clĞ´484. With the evaluated NV-FF FPGA performance and the DFT-FPGA performance, we can conclude that the DFT-FPGA consumes a small amount of FPGA resources and will not be the speed botleneck afer being applied to the source program. Manuscript submited to ACM", "page": 13, "position": 1}
{"chunk_id": "2002.02094v1_p14_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 15 Table 1. Tracker Resource Utilization Tracker size 4bit 5bit 6bit 7bit 8bit 9bit FPGA FFs 15 18 21 24 27 30(0.03%) 106400 LUTs 90 102 102 102 102 110(0.21%) 53200 Max Cycle 225 961 3969 16129 65025 261121 - Table 2. Control Unit Resource Utilization Tracker size 4bit 5bit 6bit 7bit 8bit 9bit FPGA FFs 52 52 52 52(0.05%) 36 36 106400 LUTs 138 142 150 166(0.31%) 134 134 53200 BRAM âˆ¼ âˆ¼ âˆ¼ âˆ¼ 2 2 280 Table 3. DFT-FPGA Working Frequency Frequency 100MHz 150MHz 200MHz 400MHz 450MHz 500MHz 600MHz Tracker âˆš âˆš âˆš âˆš âˆš âˆš Ã— Control Unit âˆš âˆš âˆš âˆš Ã— Ã— Ã— DFT-FPGA âˆš âˆš âˆš âˆš Ã— Ã— Ã— 5.3 DFT-FPGA Case study In the previous section, we showed the performance of a tracker, a control unit and an individual DFT-FPGA frame- work. In this section, we evaluate the performance of HLS benchmarks from CHStone [48] on FPGA xc7z020clĞ´484 with/without applying DFT-FPGA under 400 MHz working frequency. Te benchmarks cover large size benchmark such as adpcm and small size benchmark such as struct. Table 4 and 5 show the resource utilization of source benchmarks and benchmarks applyied DFT-FPGA (DFT). In the table, resources such as BRAM, DSP, ï¬‚ip-ï¬‚op, LUT, and SLICE are listed. For the source benchmarks, the resource usage and utilization level are presented. For DFT-FPGA, its resource usage includes source benchmark and the applied DFT-FPGA framework. Te resource usage and utilization level increment are shown in the table for DFT-FPGA. For benchmarks with higher resource utilization, such as adpcm, aes, Ğ´sm, and f loat, a less than 1.5% resource increment is observed. DFT-FPGA generates trackers and control unit to track their data ï¬‚ow. For small benchmarks such as Ğ´lobal and struct, less than 0.3% resource increment is observed. Such benchmarks consume a small number of ï¬‚ip-ï¬‚ops and LUTs, which is even less than its trackerâ€™s resource requirement. For such benchmarks, DFT-FPGA only generates control unit to keep all associated SLICE addresses and save all data. In this way, DFT-FPGA", "page": 14, "position": 0}
{"chunk_id": "2002.02094v1_p14_c1", "doc_id": "2002.02094v1", "text": "increment is observed. DFT-FPGA generates trackers and control unit to track their data ï¬‚ow. For small benchmarks such as Ğ´lobal and struct, less than 0.3% resource increment is observed. Such benchmarks consume a small number of ï¬‚ip-ï¬‚ops and LUTs, which is even less than its trackerâ€™s resource requirement. For such benchmarks, DFT-FPGA only generates control unit to keep all associated SLICE addresses and save all data. In this way, DFT-FPGA achieves resource eï¬ƒciency in diï¬€erent sizes of benchmarks. Te proposed design shows good adaptability when source programsâ€™ size scales up and scales down. It consumes a small number of FPGA resources to achieve intermediate data tracking in the analyzed benchmarks. Table 4. DFT-FPGA in Diï¬€erent Benchmarks Benchmarks adpcm aes gsm FPGA source DFT source DFT source DFT BRAM 14(5%) 16 (+0.7%) 9(3%) 11 (+0.07%) 7(2.5%) 9 (+0.7%) 280 DSP 114(51.8%) 114(+0%) 0(0%) 0(+0%) 46(20.9%) 46(+0%) 220 FF 3464(3.3%) 3769 (+0.28%) 1028(0.96%) 1321 (+0.28%) 1435(1.3%) 1682 (+0.23%) 106400 LUT 8293(15.6%) 8928 (+1.2%) 4552(8.6%) 5330 (+1.5%) 3903(7.3%) 4487 (+1%) 53200 SLICE - 472 - 166 - 211 13300 Manuscript submited to ACM", "page": 14, "position": 1}
{"chunk_id": "2002.02094v1_p15_c0", "doc_id": "2002.02094v1", "text": "16 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu Table 5. DFT-FPGA in Diï¬€erent Benchmarks Benchmarks ï¬‚oat global struct FPGA source DFT source DFT source DFT BRAM 14(5%) 16 (+0.7%) 3(1%) 3 (+0%) 4(1.4%) 4(+0%) 280 DSP 14(6.4%) 14(+0%) 0(0%) 0(+0%) 0(0%) 0(+0%) 220 FF 2997(2.8%) 3210 (+0.2%) 74(0.07%) 284 (+0.19%) 58(0.05%) 267 (+0.19%) 106400 LUT 4901(9.2%) 5150 (+0.47%) 713(1.3%) 882 (+0.3%) 228(0.4%) 380 (+0.28%) 53200 SLICE - 402 - 36 - 34 13300 5.4 Comparison DFT-FPGA with Checkpoint Technology In the previous section, we evaluated the resource utilization of DFT-FPGA in diï¬€erent benchmarks. In this section, we will present the comparison between DFT-FPGA and periodical checkpoint CP-FPGA in resource, roll-back time, and ï¬‚ip-ï¬‚op storing under diï¬€erent power conditions. As CP-FPGA places checkpoints at the end of all states and saves checkpoint to a BRAM, the number of extra BRAMs brought by CP-FPGA equals the number of states in a benchmark. In the proposed design, the extra BRAM is brought by control unit, which stores SLICE addresses. In table 6, we show the number of states in each benchmark and BRAM utilization in DFT-FPGA and CP-FPGA. In FPGA xc7z020clĞ´484, a single BRAM stores 18Kb data. As shown in the table, the BRAM resource is signiï¬cantly decreased in DFT-FPGA. Tis is because the BRAM in DFT-FPGA is generated according to the number of SLICEs needed to be tracked. Each BRAM in DFT-FPGA is fully utilized. BRAM in CP-FPGA can not be fully utilized as it is assigned by state number, regardless of the size of state result. Table 6. BRAM usage in DFT-FPGA and CP-FPGA Benchmarks adpcm aes gsm ï¬‚oat global struct states 24 8 13 1 3 2 BRAM DFT 2 2 2 2 0 0 BRAM CP 24(12x) 8(4x) 13(6.5x) 1 3(3x) 2(2x) Te roll-back time and the number of stored ï¬‚ip-ï¬‚ops in diï¬€erent benchmarks are shown in Figure 13 and Figure 14. In Fig. 13, the x-axis shows the number of power lost during benchmarks running and the y-axis shows the roll-back clock cycles. Power lost is randomly triggered within a benchmarkâ€™s", "page": 15, "position": 0}
{"chunk_id": "2002.02094v1_p15_c1", "doc_id": "2002.02094v1", "text": "13 1 3 2 BRAM DFT 2 2 2 2 0 0 BRAM CP 24(12x) 8(4x) 13(6.5x) 1 3(3x) 2(2x) Te roll-back time and the number of stored ï¬‚ip-ï¬‚ops in diï¬€erent benchmarks are shown in Figure 13 and Figure 14. In Fig. 13, the x-axis shows the number of power lost during benchmarks running and the y-axis shows the roll-back clock cycles. Power lost is randomly triggered within a benchmarkâ€™s computation length, e.g at power lost is 5, there are 5 power lost during computing and every power lost is randomly triggered. In the evaluation, we simulate the number of power lost from 1 to 10 during the computation to mimic diï¬€erent power conditions. Without loss of generality, for each power lost case, we record the result of its mean of 10 test rounds. As shown in the ï¬gure, the roll-back time for the proposed design is near zero in all benchmarks and all power conditions. Our performance is not inï¬‚uenced even if power condition is worse. Tis is because the data ï¬‚ow inside each state is aware by DFT-FPGA; DFT-FPGA can retrieve computation from where it is interrupted. For CP-FPGA, it needs to ï¬nd its nearest checkpoint and recover from that point. If the length of states is long in benchmarks, the interval between two checkpoints is far from each other. It causes long roll-back if power is lost during the middle of such state. Tis is observed in the Ğ´sm benchmark which consists of multiple states with over one thousand cycles each. When power lost occurs in one of such states, long roll-back happens. Te performance of periodical placing checkpoint technology is signiï¬cantly inï¬‚uenced by the source program and power condition. Meanwhile, the proposed DFT-FPGA shows good adaptability in minimized roll-back time for diï¬€erent benchmarks in diï¬€erent power conditions. Figure 14 shows the stored ï¬‚ip-ï¬‚op data for benchmarks in diï¬€erent power conditions. In this ï¬gure, we record the number of ï¬‚ip-ï¬‚ops that are stored in CP-FPGA and the proposed design. Te x-axis shows the power lost case Manuscript submited to ACM", "page": 15, "position": 1}
{"chunk_id": "2002.02094v1_p16_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 17 ranging from 1 to 10. Te y-axis shows the number of ï¬‚ip-ï¬‚ops that are stored afer ï¬nishing computation. As CP-FPGA periodically places checkpoints in design, the number of ï¬‚ip-ï¬‚ops stored is a constant in all power conditions. Afer a state is called, it stores its state result data in registers to BRAM as a checkpoint. It leads to unnecessary data storing when power lost happens occasionally such as once or twice in computation. For DFT-FPGA, the number of ï¬‚ip-ï¬‚ops which is saved consists of both intermediate data registers and trackersâ€™ ï¬‚ip-ï¬‚op resources. We can observe linear increasing in ï¬‚ip-ï¬‚ops when the number of power lost becomes worse. Tis is because the data storage in DFT-FPGA happens only at power lost. Periodical placing checkpoint may have fewer ï¬‚ip-ï¬‚ops usages if a small number of checkpoints are placed. Such as truct, it is arranged to several long states. CP-FPGA have less ï¬‚ip-ï¬‚op storing in such benchmarks. However, it brings long roll-back time as shown in Fig. 13. 0 5 10 0 100 200 300 adpcm_cp adpcm_dft 0 5 10 0 50 100 aes_cp aes_dft 0 5 10 0 1000 2000 3000 4000 gsm_cp gsm_dft 0 5 10 0 50 100 150 200 float_cp float_dft 0 5 10 0 5 10 global_cp global_dft 0 5 10 0 10 20 30 struct_cp struct_dft Fig. 13. Roll-back time in CP-FPGA and DFT-FPGA. 0 5 10 0 2 4 6 104 adpcm_cp adpcm_dft 0 5 10 0 1000 2000 3000 aes_cp aes_dft 0 5 10 0 1000 2000 3000 gsm_cp gsm_dft 0 5 10 0 5000 10000 15000 float_cp float_dft 0 5 10 0 0.5 1 1.5 2 104 global_cp global_dft 0 5 10 0 500 1000 1500 2000 struct_cp struct_dft Fig. 14. Flip-flop operations in CP-FPGA and DFT-FPGA. 6 CONCLUSION We propose a data-ï¬‚ow tracking framework, DFT-FPGA, for non-volatile FPGA. It is a full High-Level-Synthesis based framework targeting non-volatile FPGA that can online track and locate the physical location of intermediate data. By parsing, storing, and retrieving certain area of FPGA SLICE, the", "page": 16, "position": 0}
{"chunk_id": "2002.02094v1_p16_c1", "doc_id": "2002.02094v1", "text": "0.5 1 1.5 2 104 global_cp global_dft 0 5 10 0 500 1000 1500 2000 struct_cp struct_dft Fig. 14. Flip-flop operations in CP-FPGA and DFT-FPGA. 6 CONCLUSION We propose a data-ï¬‚ow tracking framework, DFT-FPGA, for non-volatile FPGA. It is a full High-Level-Synthesis based framework targeting non-volatile FPGA that can online track and locate the physical location of intermediate data. By parsing, storing, and retrieving certain area of FPGA SLICE, the proposed design can assist NV-FPGA in intermitent computing with minimum resource overhead. Te proposed DFT-FPGA also shows good adaptability in diï¬€erent benchmarks under various power conditions with beter resource utilization and less roll-back time. 7 ACKNOWLEDGEMENTS Tis work was supported in part by the National Science Foundation under Grant CCF-1820537, in part by the National Natural Science Foundation of China under Grant 61934005, in part by the National Natural Science Foundation of China under Grant 61674094, in part by the National Science Foundation under Grant CCF-1527464, and in part by the Research Grants Council of the Hong Kong Special Administrative Region, China under Grant CityU 11278316. REFERENCES [1] Xiaowei Xu, Yukun Ding, Sharon Xiaobo Hu, Michael Niemier, Jason Cong, Yu Hu, and Yiyu Shi. Scaling for edge inference of deep neural networks. Nature Electronics, 1(4):216, 2018. [2] Xiaowei Xu, Qing Lu, Tianchen Wang, Jinglan Liu, Cheng Zhuo, Xiaobo Sharon Hu, and Yiyu Shi. Edge segmentation: Empowering mobile telemedicine with compressed cellular neural networks. In Proceedings of the 36th International Conference on Computer-Aided Design, pages 880â€“887. IEEE Press, 2017. [3] Xiaowei Xu, Dewen Zeng, Wenyao Xu, Yiyu Shi, and Yu Hu. An eï¬ƒcient memristor-based distance accelerator for time series data mining on data centers. In 2017 54th ACM/EDAC/IEEE Design Automation Conference (DAC), pages 1â€“6. IEEE, 2017. Manuscript submited to ACM", "page": 16, "position": 1}
{"chunk_id": "2002.02094v1_p17_c0", "doc_id": "2002.02094v1", "text": "18 Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtong Hu [4] Latice. ice40 lp/hx/lm. latice, 2017. [5] Xifan Tang, Pierre-Emmanuel Gaillardon, and Giovanni De Micheli. A high-performance low-power near-vt rram-based fpga. In 2014 International Conference on Field-Programmable Technology (FPT), pages 207â€“214. IEEE, 2014. [6] Xifan Tang, Gain Kim, Pierre-Emmanuel Gaillardon, and Giovanni De Micheli. A study on the programming structures for rram-based fpga architectures. IEEE Transactions on Circuits and Systems I: Regular Papers, 63(4):503â€“516, 2016. [7] Weisheng Zhao, Eric Belhaire, Claude Chappert, and Pascale Mazoyer. Spin transfer torque (st)-mramâ€“based runtime reconï¬guration fpga circuit. ACM Transactions on Embedded Computing Systems (TECS), 9(2):14, 2009. [8] Xiaochen Guo, Engin Ipek, and Tolga Soyata. Resistive computation: avoiding the power wall with low-leakage, st-mram based computing. In ACM SIGARCH Computer Architecture News, volume 38, pages 371â€“382. ACM, 2010. [9] Pierre-Emmanuel Gaillardon, M Haykel Ben-Jamaa, Marina Reyboz, Giovanni Beti Beneventi, Fabien Clermidy, Luca Perniola, and Ian Oâ€™Connor. Phase-change-memory-based storage elements for conï¬gurable logic. In 2010 International Conference on Field-Programmable Technology (FPT), pages 17â€“20. IEEE, 2010. [10] Yibo Chen, Jishen Zhao, and Yuan Xie. 3d-nonfar: three-dimensional non-volatile fpga architecture using phase change memory. In Proceedings of the 16th ACM/IEEE international symposium on Low power electronics and design, pages 55â€“60. ACM, 2010. [11] Albert Lee, Chieh-Pu Lo, Chien-Chen Lin, Wei-Hao Chen, Kuo-Hsiang Hsu, Zhibo Wang, Fang Su, Zhe Yuan, Qi Wei, Ya-Chin King, and Chrong-Jung Lin. A reram-based nonvolatile ï¬‚ip-ï¬‚op with self-write-termination scheme for frequent-oï¬€fast-wake-up nonvolatile processors. IEEE Journal of Solid-State Circuits, 52(8):2194â€“2207, 2017. [12] Vilabha S Patil, Yashwant B Mane, and Shraddha Deshpande. Fpga based power saving technique for sensor node in wireless sensor network (wsn). In Computational Intelligence in Sensor Networks, pages 385â€“404. Springer, 2019. [13] Billel Bengherbia, Mohamed Ould Zmirli, Abdelmoghni Toubal, and Abderrezak Guessoum. Fpga-based wireless sensor nodes for vibration monitoring system and fault diagnosis. Measurement, 101:81â€“92, 2017. [14] Abdulfatah M Obeid, Fatma Karray, Mohamed Wassim Jmal, Mohamed Abid, Syed Manzoor Qasim, and Mohammed S BenSaleh. Towards realisation of wireless sensor network-based water pipeline monitoring systems: a comprehensive review of techniques and platforms. IET science, measurement & technology, 10(5):420â€“426,", "page": 17, "position": 0}
{"chunk_id": "2002.02094v1_p17_c1", "doc_id": "2002.02094v1", "text": "pages 385â€“404. Springer, 2019. [13] Billel Bengherbia, Mohamed Ould Zmirli, Abdelmoghni Toubal, and Abderrezak Guessoum. Fpga-based wireless sensor nodes for vibration monitoring system and fault diagnosis. Measurement, 101:81â€“92, 2017. [14] Abdulfatah M Obeid, Fatma Karray, Mohamed Wassim Jmal, Mohamed Abid, Syed Manzoor Qasim, and Mohammed S BenSaleh. Towards realisation of wireless sensor network-based water pipeline monitoring systems: a comprehensive review of techniques and platforms. IET science, measurement & technology, 10(5):420â€“426, 2016. [15] T Xue and S Roundy. Analysis of magnetic plucking conï¬gurations for frequency up-converting harvesters. In Journal of Physics: Conference Series, volume 660, page 012098. IOP Publishing, 2015. [16] Kaisheng Ma, Xueqing Li, Jinyang Li, Yongpan Liu, Yuan Xie, Jack Sampson, Mahmut Taylan Kandemir, and Vijaykrishnan Narayanan. Incidental computing on iot nonvolatile processors. In Proceedings of the 50th Annual IEEE/ACM International Symposium on Microarchitecture, pages 204â€“218. ACM, 2017. [17] Kaisheng Ma, Xueqing Li, Shuangchen Li, Yongpan Liu, John Jack Sampson, Yuan Xie, and Vijaykrishnan Narayanan. Nonvolatile processor architecture exploration for energy-harvesting applications. IEEE Micro, 35(5):32â€“40, 2015. [18] Kiwan Maeng, Alexei Colin, and Brandon Lucia. Alpaca: intermitent execution without checkpoints. Proceedings of the ACM on Programming Languages, 1(OOPSLA):96, 2017. [19] Chen Pan, Mimi Xie, Yongpan Liu, Yanzhi Wang, Chun Jason Xue, Yuangang Wang, Yiran Chen, and Jingtong Hu. A lightweight progress maximization scheduler for non-volatile processor under unstable energy harvesting. In Proceedings of the 18th ACM SIGPLAN/SIGBED Conference on Languages, Compilers, and Tools for Embedded Systems, pages 101â€“110. ACM, 2017. [20] Domenico Balsamo, Alex S Weddell, Geoï¬€V Merret, Bashir M Al-Hashimi, Davide Brunelli, and Luca Benini. Hibernus: Sustaining computation during intermitent supply for energy-harvesting systems. IEEE Embedded Systems Leters, 7(1):15â€“18, 2015. [21] Mimi Xie, Mengying Zhao, Chen Pan, Jingtong Hu, Yongpan Liu, and Chun Jason Xue. Fixing the broken time machine: Consistency-aware checkpointing for energy harvesting powered non-volatile processor. In Proceedings of the 52nd Annual Design Automation Conference, page 184. ACM, 2015. [22] Mimi Xie, Mengying Zhao, Chen Pan, Hehe Li, Yongpan Liu, Youtao Zhang, Chun Jason Xue, and Jingtong Hu. Checkpoint aware hybrid cache architecture for nv processor in energy harvesting powered systems. In Proceedings of the Eleventh IEEE/ACM/IFIP", "page": 17, "position": 1}
{"chunk_id": "2002.02094v1_p17_c2", "doc_id": "2002.02094v1", "text": "Yongpan Liu, and Chun Jason Xue. Fixing the broken time machine: Consistency-aware checkpointing for energy harvesting powered non-volatile processor. In Proceedings of the 52nd Annual Design Automation Conference, page 184. ACM, 2015. [22] Mimi Xie, Mengying Zhao, Chen Pan, Hehe Li, Yongpan Liu, Youtao Zhang, Chun Jason Xue, and Jingtong Hu. Checkpoint aware hybrid cache architecture for nv processor in energy harvesting powered systems. In Proceedings of the Eleventh IEEE/ACM/IFIP International Conference on Hardware/Sofware Codesign and System Synthesis, page 22. ACM, 2016. [23] Azalia Mirhoseini, Bita Darvish Rouhani, Ebrahim Songhori, and Farinaz Koushanfar. Chime: Checkpointing long computations on interm itently energized iot devices. IEEE Transactions on Multi-Scale Computing Systems, 2(4):277â€“290, 2016. [24] Zhe Yuan, Yongpan Liu, Hehe Li, and Huazhong Yang. Cp-fpga: Computation data-aware sofware/hardware co-design for nonvolatile fpgas based on checkpointing techniques. In Design Automation Conference (ASP-DAC), 2016 21st Asia and South Paciï¬c, pages 569â€“574. IEEE, 2016. [25] P-E Gaillardon, Davide Saccheto, Giovanni Beti Beneventi, M Haykel Ben Jamaa, Luca Perniola, Fabien Clermidy, Ian Oâ€™Connor, and Giovanni De Micheli. Design and architectural assessment of 3-d resistive memory technologies in fpgas. IEEE Transactions on Nanotechnology, 12(1):40â€“50, 2013. [26] Jason Cong and Bingjun Xiao. mrfpga: A novel fpga architecture with memristor-based reconï¬guration. In 2011 IEEE/ACM International Symposium on Nanoscale Architectures, pages 1â€“8. IEEE, 2011. [27] Ramtin Zand and Ronald F DeMara. Radiation-hardened mram-based lut for non-volatile fpga sof error mitigation with multi-node upset tolerance. Journal of Physics D: Applied Physics, 50(50):505002, 2017. Manuscript submited to ACM", "page": 17, "position": 2}
{"chunk_id": "2002.02094v1_p18_c0", "doc_id": "2002.02094v1", "text": "Low Overhead Online Data Flow Tracking for Intermitently Powered Non-volatile FPGAs 19 [28] Kangwook Jo, Kyungseon Cho, and Hongil Yoon. Variation-tolerant and low power look-up table (lut) using spin-torque transfer magnetic ram for non-volatile ï¬eld programmable gate array (fpga). In 2016 International SoC Design Conference (ISOCC), pages 101â€“102. IEEE, 2016. [29] Haider Abbas F Almurib, Tulasiraman Nandha Kumar, and Fabrizio Lombardi. Design and evaluation of a memristor-based look-up table for non-volatile ï¬eld programmable gate arrays. IET Circuits, Devices & Systems, 10(4):292â€“300, 2016. [30] Ramin Rajaei. Radiation-hardened design of nonvolatile mram-based fpga. IEEE Transactions on Magnetics, 52(10):1â€“10, 2016. [31] Lei Ju, Xiaojin Sui, Shiqing Li, Mengying Zhao, Chun Jason Xue, Jingtong Hu, and Zhiping Jia. Nvm-based fpga block ram with adaptive slc-mlc conversion. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 37(11):2661â€“2672, 2018. [32] H-S Philip Wong, Heng-Yuan Lee, Shimeng Yu, Yu-Sheng Chen, Yi Wu, Pang-Shiu Chen, Byoungil Lee, Frederick T Chen, and Ming-Jinn Tsai. Metalâ€“oxide rram. Proceedings of the IEEE, 100(6):1951â€“1970, 2012. [33] Santhosh Onkaraiah, Marina Reyboz, Fabien Clermidy, Jean-Michel Portal, Marc Bocquet, Chritophe Muller, Hraziia, Costin Anghel, and Amara Amara. Bipolar reram based non-volatile ï¬‚ip-ï¬‚ops for low-power architectures. In 2012 IEEE 10th International New Circuits and Systems Conference (NEWCAS), pages 417â€“420. IEEE, 2012. [34] K Jabeur, G Di Pendina, and G Prenat. Ultra-energy-eï¬ƒcient cmos/magnetic nonvolatile ï¬‚ip-ï¬‚op based on spin-orbit torque device. Electronics Leters, 50(8):585â€“587, 2014. [35] Tsai-Kan Chien, Lih-Yih Chiou, Yao-Chun Chuang, Shyh-Shyuan Sheu, Heng-Yuan Li, Pei-Hua Wang, Tzu-Kun Ku, Ming-Jinn Tsai, and Chih-I Wu Wu. A low store energy and robust reram-based ï¬‚ip-ï¬‚op for normally oï¬€microprocessors. In 2016 IEEE International Symposium on Circuits and Systems (ISCAS), pages 2803â€“2806. IEEE, 2016. [36] Xilinx. Xilinx ï¬‚oorplanning methodology guide. Xilinx, 2009. [37] Razvan Nane, Vlad-Mihai Sima, Christian Pilato, Jongsok Choi, Blair Fort, Andrew Canis, Yu Ting Chen, Hsuan Hsiao, Stephen Brown, Fabrizio Ferrandi, et al. A survey and evaluation of fpga high-level synthesis tools. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 35(10):1591â€“1604, 2015. [38] Denis Navarro, Â´Oscar LucÄ±, Luis A BarragÂ´an, Isidro Urriza, Oscar Jimenez, et al. High-level synthesis for accelerating the fpga implementation of computationally", "page": 18, "position": 0}
{"chunk_id": "2002.02094v1_p18_c1", "doc_id": "2002.02094v1", "text": "Xilinx, 2009. [37] Razvan Nane, Vlad-Mihai Sima, Christian Pilato, Jongsok Choi, Blair Fort, Andrew Canis, Yu Ting Chen, Hsuan Hsiao, Stephen Brown, Fabrizio Ferrandi, et al. A survey and evaluation of fpga high-level synthesis tools. IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems, 35(10):1591â€“1604, 2015. [38] Denis Navarro, Â´Oscar LucÄ±, Luis A BarragÂ´an, Isidro Urriza, Oscar Jimenez, et al. High-level synthesis for accelerating the fpga implementation of computationally demanding control algorithms for power converters. IEEE Transactions on Industrial Informatics, 9(3):1371â€“1379, 2013. [39] Weiwen Jiang, Edwin H-M Sha, Xinyi Zhang, Lei Yang, Qingfeng Zhuge, Yiyu Shi, and Jingtong Hu. Achieving super-linear speedup across multi-fpga for real-time dnn inference. ACM Transactions on Embedded Computing Systems (TECS), 18(5s):67, 2019. [40] Weiwen Jiang, Xinyi Zhang, Edwin H-M Sha, Lei Yang, Qingfeng Zhuge, Yiyu Shi, and Jingtong Hu. Accuracy vs. eï¬ƒciency: Achieving both through fpga-implementation aware neural architecture search. arXiv preprint arXiv:1901.11211, 2019. [41] Andrew Canis, Jongsok Choi, Mark Aldham, Victor Zhang, Ahmed Kammoona, Tomasz Czajkowski, Stephen D Brown, and Jason H Anderson. Legup: An open-source high-level synthesis tool for fpga-based processor/accelerator systems. ACM Transactions on Embedded Computing Systems (TECS), 13(2):24, 2013. [42] Saad Ahmed, Muhammad Hamad Alizai, Junaid Haroon Siddiqui, Naveed Anwar Bhati, and Luca Motola. Towards smaller checkpoints for beter intermitent computing. In 2018 17th ACM/IEEE International Conference on Information Processing in Sensor Networks (IPSN), pages 132â€“133. IEEE, 2018. [43] Xinyi Zhang, Clay Paterson, Yongpan Liu, Chengmo Yang, Chun Jason Xue, and Jingtiong Hu. Low overhead online checkpoint for intermitently powered non-volatile fpgas. In 2018 IEEE Computer Society Annual Symposium on VLSI (ISVLSI), pages 238â€“244. IEEE, 2018. [44] Masood Qazi, Amerasekera Ajith, and Anantha P. Chandrakasan. A 3.4pj feram-enabled d ï¬‚ip-ï¬‚op in 0.13m cmos for nonvolatile processing in digital systems. In 2013 IEEE International Solid-State Circuits Conference Digest of Technical Papers. IEEE, 2013. [45] Farheen Fatima Khan and Andy Ye. A study on the accuracy of minimum width transistor area in estimating fpga layout area. Microprocessors and Microsystems, 52:287â€“298, 2017. [46] Srihari Cadambi, Abhinandan Majumdar, Michela Becchi, Srimat Chakradhar, and Hans Peter Graf. A programmable parallel accelerator for learning and classiï¬cation.", "page": 18, "position": 1}
